springCloud eureka 服务端的使用：
	http://www.ityouknow.com/springcloud/2017/05/10/springcloud-eureka.html

	Eureka Server 服务中心，提供服务注册和发现
	1、pom中添加依赖
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter</artifactId>
			</dependency>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka-server</artifactId>
			</dependency>
		</dependencies>
	2、启动类添加@EnableEurekaServer注解
	3、配置文件

	添加以下配置：
		#应用名。注册根据应用名判断是否为同一个应用，多个同一个应用就是集群。
		spring.application.name=spring-cloud-eureka
		#应用端口。
		server.port=8000
		#是否将自己注册到Eureka Server，默认为true。
		eureka.client.register-with-eureka=false
		#是否从Eureka Server获取注册信息，默认为true。
		eureka.client.fetch-registry=false
		#Eureka Server地址，与Eureka Server交互的地址。查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；
		#集群多个地址可使用,分隔。
		eureka.client.serviceUrl.defaultZone=http://localhost:${server.port}/eureka/

		附：
			？：
				在默认设置下，Eureka Server在启动时默认会注册自己，成为一个服务。
				Eureka Server也成为一个客户端，所以我们需要禁用它的客户端注册行为。
				
				为啥要关闭了，是只有一个服务端是才关闭吗？
				https://cloud.tencent.com/developer/article/1494956
	启动工程后，访问：http://localhost:8000/，服务注册中心的页面

	
	springCloud eureka 服务端集群的使用：
		介绍：
			注册中心这么关键的服务，如果是单点话，遇到故障就是毁灭性的。
			Eureka通过互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署。
		双节点注册中心：
			两个项目Eureka Server交互的地址互相指向
			eureka.client.serviceUrl.defaultZone=http://peer2:8001/eureka/
			eureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/

		注：
			1.多节点：
			生产中需要大于三台的注册中心来保证服务的稳定性，配置的原理和双节点一样，
			只是每台注册中心分别指向其它两个节点即可。
			2.激活不同的配置来启用不同的节点：
				java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1
springCloud eureka 客户端的使用：
	http://www.ityouknow.com/springcloud/2017/05/12/eureka-provider-constomer.html
	服务提供：
		1.引入client依赖：
			<dependencies>
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					<artifactId>spring-cloud-starter</artifactId>
				</dependency>
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					<artifactId>spring-cloud-starter-eureka-client</artifactId>
				</dependency>
			</dependencies>
		2.配置与Eureka Server交互的地址
			spring.application.name=spring-cloud-producer
			server.port=9000
			eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/
			
		3.启动类中添加@EnableDiscoveryClient注解
			附：
			@EnableDiscoveryClient：
				启用服务注册与发现。
				添加@EnableDiscoveryClient注解后，此时这个项目就会被注册到eureka服务中心，客户端就可以访问到改项目中所有的controller了。
				！：
				那如果我有controller不想被别人调用了。通过security吧。
			
	服务调用：
		1.引入client依赖。
		2.配置与Eureka Server交互的地址
		3.启动类添加@EnableDiscoveryClient和@EnableFeignClients注解。
		附：
			@EnableFeignClients：
				启用feign。
				Feign是一个声明式Web Service客户端。				
				Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。
		4、使用feign代理远程对象：
		hcg:使用feign实现一个本地远程代理对象。属于设计模式中的远程代理。
		@FeignClient(name= "spring-cloud-producer")
		public interface HelloRemote {
			@RequestMapping(value = "/hello")
			public String hello(@RequestParam(value = "name") String name);
		}
		注：
			feign的用法：
				它的使用方法是定义一个接口，然后在方法上添加注解来代理远程对象。
					同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。
				接口中的方法和远程服务contoller中的方法名和参数,注解等保持一致。
				@FeignClient:
					name:远程服务名。就是远程服务提供者配置中的spring.application.name名称
				
		5、代码中调用代理对象：
		例：
		将HelloRemote注入到controller层，像平常一样去调用即可。
			@Autowired
			HelloRemote HelloRemote;
			方法(){
				return HelloRemote.hello("test");
			}


附：
	依次启动spring-cloud-eureka、spring-cloud-producer、spring-cloud-consumer三个项目，即可进行一个微服务框架应用的测试。

	Eureka概念原理：
		https://www.jianshu.com/p/2fa691d4a00a
		./eureka如何管理服务调用.png
	Springcloud中的region和zone的使用
		https://www.cnblogs.com/nxzblogs/p/11681929.html
		Spring cloud实现FeignClient指定Zone调用
			https://blog.csdn.net/zhxdick/article/details/91868730?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf
			eureka.instance.metadata-map.zone设置不同实例所属的zone，zone之间不互相调用，只有zone内部调用（其实这里用zone做了集群隔离，实际上集群肯定是跨可用区的，这里的eureka中的zone在我们项目里面并不是可用区的概念）。
	Feign与Ribbon...
	
		Ribbon是一个基于 HTTP 和 TCP 客户端 的负载均衡的工具。它可以 在客户端 配置RibbonServerList（服务端列表），使用 HttpClient 或 RestTemplate 模拟http请求，步骤相当繁琐。

​ Feign 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端。采用接口的方式， 只需要创建一个接口，然后在上面添加注解即可 ，将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写客户端变得非常容易