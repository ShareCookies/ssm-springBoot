P98
https://www.cnblogs.com/SummerinShire/p/6392242.html
环境:
	在开发软件过程一个很大的挑战就是将应用程序从一个环境迁移到另外一个环境。
	profile就是为应对不同开发环境而开发的。
	如开发阶段中，数据库配置、外部系统的集成是跨环境部署时会发生变化的几个典型例子。
profile：
	Spring中的Profile功能发布在Spring 3.1版本。
	只有当Profile被激活的时候，才会将Profile对应的配置属性和对应的Bean注册到Spring容器中。
	
	解析：
		举个更具体的例子，我们以前所定义的Bean，当Spring容器一启动的时候，就会一股脑的全部加载这些信息完成对Bean的创建。
		而使用了Profile之后，它会将Bean的定义进行更细粒度的划分，会跟据bean的profile信息将这些定义的Bean划分为几个不同的组，
		当Spring容器加载配置信息的时候，首先查找激活的Profile，然后只会去加载被激活的组中所定义的Bean信息，而不被激活的Profile中所定义的Bean定义信息是不会加载用于创建Bean的。
激活profile:  
	激活Profile的几种方式:  
		1.使用@ActiveProfiles注解来激活profile:  
		2.通过spring.profiles.active属性,来激活profile:
		3.通过spring.profiles.default属性,来激活profile:
		注：
			profile是可以同时激活多个的
		属性激活的解析：
			如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。
			但如果没有设置spring.profiles.active属性的话，那Spring将会查找spring.profiles.default的值。
			如果spring.profiles.active和spring.profiles.default均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。

		设置active和default属性多种方式：
			这两个属性值其实是Spring容器中定义的属性，而我们在实际的开发中很少会直接操作Spring容器本身。
			所以这两个属性，要设置在指定的位置上，让Spring容器自动去这些位置读取，然后自动设置。
			这些位置可以为以下地方：
				作为DispatcherServlet的初始化参数；
				作为Web应用的上下文参数；
				作为JNDI条目；
				作为环境变量；
				作为JVM的系统属性；
				在集成测试类上，使用@ActiveProfiles注解设置。
					
配置profile bean：（或叫指定bean属于那个profile）
	废话：
		Spring为环境相关的bean所提供的解决方案其实与构建时的方案没有太大的差别。
		在这个过程中需要根据环境决定该创建哪个bean和不创建哪个bean。
		不过Spring并不是在构建的时候做出这样的决策，而是等到运行时再来确定。
		这样的结果就是同一个部署单元（可能会是WAR文件）能够适用于所有的环境，没有必要进行重新构建。
	介绍：
		只有当指定的profile环境激活的时候，该bean才会被创建。
	Java配置中配置profile bean：
		在Java配置中，可以使用@Profile注解指定某个bean属于哪一个profile。
		即对应的 profile激活的时候，才会创建对应的bean。
	XML中配置profile bean：
		通过<beans>元素的profile属性，在XML中配置profile bean。
条件化的bean：
	介绍：
		如果你希望某个bean只有当另外某个特定的bean也声明了之后才会创建。
		或多个bean只有在应用的类路径下包含特定的库时才创建。
		hcg：
			即bean只有在符合你指定的条件下，才会被创建。
			注：
				profile是无法实现这些这么细致的指定的，profile中只要是属于该profile的bean都会被创建。
	使用：
		...
		Spring 4引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。
		如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。
 

