p117

介绍：
	在默认情况下，Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。
	也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。
Spring定义了多种作用域，可以基于这些作用域创建bean：
		单例（Singleton）：
			默认。在整个应用中，只创建bean的一个实例。
		原型（Prototype）：
			每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。
			例:
				如果购物车是原型作用域的，
				那么在应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了，
				因为在这里注入的是另外一个原型作用域的购物车。
		会话（Session）：
			在Web应用中，为每个会话创建一个bean实例。
			使用注意点：
				@Scope(value=WebApplicationContext中SCOPE_SESSION,proxyMode=ScopedProxyMode.INTERFACES)
				1.如果注解类是接口，proxyMode设置为ScopedProxyMode.INTERFACES
				2.如果注解类是具体类，proxyMode设置为ScopedProxyMode.TARGET_CLASS
				proxyMode解析：
					proxyMode属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。					
					以下举个例子：
						StoreService是一个单例的bean，要注入一个ShoppingCart，ShoppingCart是会话bean。
						StoreService会在Spring应用上下文加载的时候创建，当它创建的时候，Spring会试图将ShoppingCart bean注入。
						但是ShoppingCart bean是会话作用域的，此时并不存在。
						
						直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。
						另外，系统中将会有多个ShoppingCart实例：每个用户一个。
						我们并不想让Spring注入某个固定的ShoppingCart实例到StoreService中。我们希望的是当StoreService处理购物车功能时，它所使用的ShoppingCart实例恰好是当前会话所对应的那一个。
						
						Spring并不会将实际的ShoppingCart bean注入到StoreService中，
						Spring会注入一个到ShoppingCart bean的代理，如图3.1所示。
						这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。
						但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。
			xml中声明会话型bean：
				p121
				
		请求（Rquest）：
			在Web应用中，为每个请求创建一个bean实例。
			使用注意点：
				请求作用域与会话作用域 面临相同的装配问题，
				因此请求作用域的bean应该也以作用域代理的方式进行注入。

			
规定bean的作用域：
	在bean的定义类上使用@Scope注解，将其声明为指定作用域的bean。
	例：
		@Component
		@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) //@Scope("prototype")
		public Class DefineBean{...}
	注：
		1.也可以在Java配置中规定bean的作用域，组合使用@Scope和@Bean来指定所需的作用域。
		2.也可以在XML中规定bean的作用域，可以使用<bean>元素的scope属性来设置作用域。
		