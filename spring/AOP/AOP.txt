AOP模块:
	介绍：
		面向切面编程，aspect-oriented programming，AOP。允许你把遍布应用各处的功能分离出来形成可重用的组件。
		历史：
			系统由许多不同的组件组成，每一组件除了实现自身核心的功能之外，还经常承担着额外的职责。
			诸如日志等，如果将这些关注点（关注点就是日志指日志等）分散到多个组件中去，你的代码将会带来双重的复杂性，
			即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。
			
		aop作用：
			AOP能够使这些关注点模块化，并以声明的方式将它们应用到它们需要影响的组件中去。
		好处：
			能够使组件具有更高的内聚性，更关注自身的业务，不需要了解涉及系统服务所带来复杂性。
			总之，AOP能够确保POJO的简单性。
			hcg：
				使你的代码只需关注业务，避免代码的臃肿和难以理解等。
AOP术语:
	常用术语有通知（advice）、切点（pointcut）和连接点（join point）。
	通知（Advice）
		切面的要完成的工作被称为通知。
		通知还解决了何时执行这个工作的问题。即：是前置还是后置
		注：
			一个切面有多个通知，即：一个切面要完成多个工作。
		Spring切面可以应用5种类型的通知：
			前置通知（Before）：在目标方法被调用之前调用通知功能；
			后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；
			返回通知（After-returning）：在目标方法成功执行之后调用通知；
			异常通知（After-throwing）：在目标方法抛出异常后调用通知；
			环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。
	连接点（Join point）:
		在应用执行过程中能够插入切面的一个点，就算连接点。
		切面在指定的连接点被织入到目标对象中。
		即：
			能插入切面的地方都算连接点，无需用代码定义连接点。？
		注：
			Spring只支持方法级别的连接点。
	切点（Poincut）
		切点的定义，会匹配通知织入到一个或多个连接点。
		即：
			切点用于准确定位应该在什么地方应用切面的通知。
	切面（Aspect）
		切面是通知和切点的结合。
			即：何处（切点），何时，做什么（通知）。
		
	引入（Introduction）
		引入允许我们向现有的类添加新方法或属性。
		
	织入（Weaving）
		织入是把切面应用到目标对象并创建新的代理对象的过程。
		目标对象生命周期能进行织入时间点：
			编译期，类加载期，运行期。
		
Spring提供了4种类型的AOP支持：
	基于代理的经典Spring AOP；
		经典意味着曾经辉煌过，但Spring经典的AOP现在显得笨重和复杂。
	纯POJO切面；？
	@AspectJ注解驱动的切面；？
	注入式AspectJ切面（适用于Spring各版本）。？



切点定义：
	在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。
	AspectJ指示器：
		P145
		arg():
			限制连接点匹配参数为指定类型的执行方法
		@args():
			限制连接点匹配参数由指定注解标注的执行方法
		execution() :
			用于匹配是连接点的执行方法
		this() :
			限制连接点匹配AOP代理的bean引用为指定类型的类
		target :
			限制连接点匹配目标对象为指定类型的类
		@target():
			限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类
			型的注解
		within() :
			限制连接点匹配指定的类型
		@within():
			限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）
		@annotation :
			限定匹配带有指定注解的连接点
		注：
			execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。
	切点中选择bean：
		除了表4.1所列的指示器外，Spring还引入了一个新的bean()指示器，它允许我们在切点表达式中使用bean的ID来标识bean。
		bean()中使用bean ID或bean名称作为参数来限制切点只匹配特定的bean。
	例：
		1.execution(* 包名.类名.方法(..) ) 
		解析：
			使用 * 不关心方法返回值的类型。
			使用全限定类名和方法名，指定要匹配的方法名。
			使用两个点号（..）表明切点要选择任意的perform()方法，无论该方法的入参是什么。
		2.AspectJ切点表达式.png
	注：
		Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。
		定义可重用切点：
			@Pointcut注解能够在一个@AspectJ切面内定义可重用的切点。
			p150
定义通知：
	AspectJ提供了五个注解来定义通知：
		@After 通知方法会在目标方法返回或抛出异常后调用
		@AfterReturning 通知方法会在目标方法返回后调用
		@AfterThrowing 通知方法会在目标方法抛出异常后调用
		@Around 通知方法会将目标方法封装起来
		@Before 通知方法会在目标方法调用之前执行
		这些注解都给定了一个切点表达式作为它的值。
		注：
			使用@Pointcut注解扩展了切点表达式语言：
				p150
	例：
		定义切面.png	
	环绕通知:
		案例中切面在定义时，使用了不同的通知方法来实现前置通知和后置通知。
		环绕通知与其他类型的通知的用法有所不同。
		p152
	通知中的参数：p154
		切面的通知中访问和使用传递给被通知方法的参数。
		

1.声明切面之注解:
	织入：
		切面的织入能够为能够为现有的方法增加额外的功能
		I.使用注解创建切面:
			通过用@Aspect注解把任意类转变为切面。
			切面类中使用注解创建切点和通知
			例：
				定义切面.png
		II.
			I.将切面类注册为bean
			II.解析使用了AspectJ注解的bean：
				配置中开启aop注解解析后，使用了切面注解的bean，springAOP模块会自动将其转换为切面的代理。
				1.java配置中启用aop解析：p151
					JavaConfig中启用AspectJ注解的自动代理：
					在配置类的类级别上使用@EnableAspectJAutoProxy注解启用自动代理功能。
					
				2.XML配置中启用aop解析：p151
					XML中启用AspectJ注解的自动代理：
					I.启用Spring的aop命名空间
					II.使用Spring aop命名空间中的<aop:aspectj-autoproxy>元素，启用AspectJ注解的自动代理。
		注：
			Spring的AspectJ自动代理仅仅使用@AspectJ作为创建切面的指导，切面依然是基于代理的。
			在本质上，它依然是Spring基于代理的切面。
			这意味着.。
	引入：p159
		引入可以不用直接修改对象或类的定义就能够为对象或类增加新的方法。
		
		Java并不是动态语言，一旦类编译完成了，我们就很难再为该类添加新的方法了。
		但springAOP的实现是基于代理机制，
		在Spring中，切面只是实现了它们所包装bean相同接口的代理。？
		所以切面的引入能为bean添加新的方法。
		
		注：
			当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。
			实际上，一个bean的实现被拆分到了多个类中。
		例：
			aop引入接口.png
2.XML中声明切面：p161
			
			
注入AspectJ切面：p169
	虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP 是一个功能比较弱的AOP解决方案。
	即AspectJ提供了SpringAOP所不能支持的许多类型的切点。
	......