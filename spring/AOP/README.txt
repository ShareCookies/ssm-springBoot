历史：
	oop的（面向对象编程）封装要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。
	这样代码就分散到一个个的类中去了。
	这样做的好处是降低了代码的复杂程度，使类可重用。但是在分散代码的同时，也增加了代码的重复性。
		系统由许多不同的组件组成，每一组件除了实现自身核心的功能之外，还经常承担着额外的职责。
		诸如日志等，如果将这些关注点（关注点就是日志指日志等）分散到多个组件中去，你的代码将会带来双重的复杂性，
		即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。

AOP模块:
	https://blog.csdn.net/qq_22654611/article/details/52606960/
	介绍：
		面向切面编程，aspect-oriented programming，AOP。
		在运行时，动态地将代码切入到类的指定方法的指定位置上的编程思想就是面向切面的编程。
			在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。
	附录：
		aop作用：
			允许你把遍布应用各处的功能分离出来形成可重用的组件。
		好处：
			能够使组件具有更高的内聚性，更关注自身的业务，不需要了解涉及系统服务所带来复杂性。
			总之，AOP能够确保POJO的简单性。
			hcg：
				使你的代码只需关注业务，避免代码的臃肿和难以理解等。
AOP术语:
	注：
		术语是对某一学科（或技术），的某一专业名词（或知识点）的称呼。
	通知（Advice）
		切面的要完成的工作被称为通知。
		通知还解决了何时执行这个工作的问题。即：方法前置还是后置等。
		注：
			一个切面有多个通知，即：一个切面要完成多个工作。
		Spring切面可以应用5种类型的通知：
			前置通知（Before）：在目标方法被调用之前调用通知功能；
			后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；
			返回通知（After-returning）：在目标方法成功执行之后调用通知；
			异常通知（After-throwing）：在目标方法抛出异常后调用通知；
			环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。
		附：
			Spring通知是Java编写的。
			Spring在运行时通知对象。
				./spring以代理实现aop的原理图.png
	连接点（Join point）:
		能够被插入切面的一个点，就算连接点。
		这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。
		注：
			能插入切面的地方都算连接点，无需用代码定义连接点。
		注：
			Spring只支持方法级别的连接点。
	切点（Poincut）
		切点的定义，会匹配通知织入到一个或多个连接点。
		即：
			切点用于准确定位应该在什么地方应用切面的通知。
	切面（Aspect）
		切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。
			即：何处（切点），何时，做什么（通知）。
		
	引入（Introduction）p159
		切面的引入功能允许我们向现有的类添加新方法或属性。
		注：
			解析：
			当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。
			实际上，一个bean的实现被拆分到了多个类中。
		例：
			./aop引入.png
	织入（Weaving）
		切面的织入功能能够为能够为现有的方法增加额外的功能
			注：
				织入是把切面应用到目标对象并创建新的代理对象的过程。
		例：
			goto：创建切面类。
		附：
			目标对象生命周期能进行织入时间点：
				编译期：
				类加载期：
				运行期：
					切面在应用运行的某个时刻被织入。
					一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。
					Spring AOP就是以这种方式织入切面的。
			?:
				但是被通知类中没有这个方法啊，调用了不会报错吗。

Spring提供了4种类型的AOP支持： 
	基于代理的经典Spring AOP；
		例：
			./例/SpringAOPAchieveSimply/
			./例/SpringAOPAchieveWithDefaultPointcutAdvisor/
			./例/SpringAOPAchieveWithNameMatchMethodPointcutAdvisor/
	纯POJO切面；(XML中声明切面)p160
		附录：
			1.借助Spring的aop命名空间，我们可以将纯POJO转换为切面。
			实际上，这些POJO只是提供了满足切点条件时所要调用的方法。
			遗憾的是，这种技术需要XML配置，但这的确是声明式地将对象转换为切面 的简便方式。
			2.
			面向注解的切面声明有一个明显的劣势，你必须能够为通知类添加注解。为了做到这一点，必须要有源码。 
			如果你没有源码的话，可考虑在Spring XML配置文件中声明切面。
	@AspectJ注解驱动的切面；
		注解实现切面(注解创建切面类)：
			介绍：
				Spring借鉴了AspectJ的切面，提供注解驱动来实现AOP，编程模型几乎与AspectJ一致。
					本质上依然是Spring基于代理来实现的AOP。
				这种AOP风格的好处在于能够不使用XML来完成功能。
				
			1.定义一个切面类:p148
				通过注解定义一个切面类。
				例：
					类使用@Aspect标注,标明这是一个切面类。
					./定义切面.png	
			2.编写切点(切点定义)：p146
				例：
					使用AspectJ的切点表达式语言来定义切点.
					./AspectJ切点表达式.png
				附：
					Spring AOP所支持的AspectJ切点指示器：P145
						切点指示器仅是构成切点表达式的一部分。
						其中execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。
					bean()指示器：p147
						Spring引入的一个新的指示器。
						允许我们在切点表达式中使用，bean ID或bean名称作为参数来限制切点只匹配特定的bean。
					*重用切点表达式：
						@Pointcut注解能够在一个@AspectJ切面内定义可重用的切点。
						例：
							p150
						注：
							@Pointcut注解标注的方法并不重要，方法本身只是一个标识，供@Pointcut注解依附。
			3.定义通知：
				例：
					使用了通知注解来表明这些方法应该在什么时候调用。
					./定义切面.png	
				注：
					1.：
						通知注解都要给定了一个切点表达式作为它的参数，
						表明这个通知会在什么地点被调用。
					2.AspectJ提供了五个注解来定义通知：p149
						@After 通知方法会在目标方法返回或抛出异常后调用
						@AfterReturning 通知方法会在目标方法返回后调用
						@AfterThrowing 通知方法会在目标方法抛出异常后调用
						@Around 通知方法会将目标方法封装起来
							环绕通知:p152
								环绕通知就像在一个通知方法中同时编写前置通知和后置通知。
						@Before 通知方法会在目标方法调用之前执行
					3.处理通知中的参数：
						如何在通知中访问和使用传递给被通知方法的参数。
						例：
							p154
			注：
				如果你就此止步的话，切面类只会是容器中的一个bean。
				即便使用了AspectJ注解，但它并不会被视为切面，这些注解不会解析，也不会创建将切面类转换为切面的代理。
			4.启用自动代理：
				在JavaConfig中启用AspectJ注解的自动代理
					p151
				xml中启用AspectJ注解的自动代理：
					p151
				AspectJ自动代理会为使用@Aspect注解的bean创建一个代理，
				这个代理会围绕着所有该切面的切点所匹配的bean。		
	注入式AspectJ切面。p169
		AspectJ提供了Spring AOP所不能支持的许多类型的切点。
		附录：
			如果你的AOP需求超过了简单的方法调用（如构造器或属性拦截）， 那么你需要考虑使用AspectJ来实现切面。
			在这种情况下，上文所示的第四种类型能够帮助你将值注入到AspectJ驱动的切面中。
	注：
		前三种都是Spring AOP实现的变体。
		Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。


