附：
	历史：
		oop的（Object Oriented Programming 面向对象编程）封装要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。
		这样代码就分散到一个个的类中去了。
		这样做的好处是降低了代码的复杂程度，使类可重用。但是在分散代码的同时，也增加了代码的重复性。
			系统由许多不同的组件组成，每一组件除了实现自身核心的功能之外，还经常承担着额外的职责。
			诸如日志等，如果将这些关注点（关注点就是日志指日志等）分散到多个组件中去，你的代码将会带来双重的复杂性，
			即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。
		接着aop思想就应运而生，它使各组件仅需实现自身核心功能，无需关心其他额外的功能，而是由对应的aop组件来实现。
		附：
			如果要重用通用功能的话，最常见的面向对象技术是继承，inheritance)或委托( delegation)。
			但是，如果在整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系;而使用委托可能需要对委托对象进行复杂的调用。
			切面提供了取代继承和委托的另一种可选方案，而且在很多场景下更清晰简洁。
			在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。
			横切关注点可以被模块化为特殊的类，这些类被称为切面(aspect) 。
			这样做有两个好处:首先，现在每个关注点都集中于-一个地方，而不是分散到多处代码中;其次，服务模块更简洁，因为它们只包含主要关注点(或核心功能)的代码，而次要关注点的代码被转移到切面中了。
AOP编程思想介绍：
	AOP aspect-oriented programming 面向切面编程。
	在运行时，动态地将代码切入到类的指定方法的指定位置上的编程思想就是面向切面编程。
		
	附：
		aop思想使各组件仅需实现自身核心功能，无需关心其他额外的功能，而是由对应的aop组件来实现。
		附：
			aop实现的核心技术是通过java代理和反射。
AOP术语:
	注：
		术语是对某一学科（或技术），的某一专业名词（或知识点）的称呼。
	通知（Advice）
		切面的要完成的工作被称为通知。
		通知还解决了何时执行这个工作的问题。即：方法前置还是后置等。
		注：
			一个切面有多个通知，即：一个切面要完成多个工作。
		Spring切面可以应用5种类型的通知：
			前置通知（Before）：在目标方法被调用之前调用通知功能；
			后置通知（After）：在目标方法完成之后调用通知（不论是正常返回还是异常退出）；
			返回通知（After-returning）：在目标方法成功执行之后调用通知；
			异常通知（After-throwing）：在目标方法抛出异常后调用通知；
			环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。环绕通知是最常用的一种通知类型。
		附：
			Spring通知是Java编写的。
			Spring在运行时通知对象。
				./spring以代理实现aop的原理图.png
	连接点（Join point）:
		能够被插入切面的一个点，就算连接点。
		这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。
		注：
			能插入切面的地方都算连接点，无需用代码定义连接点。
		注：
			Spring只支持方法级别的连接点。
	切点（Poincut）
		切点的定义，会匹配通知织入到一个或多个连接点。
		即：
			切点用于准确定位应该在什么地方应用切面的通知。
	切面（Aspect）
		切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。
			即：何处（切点），何时，做什么（通知）。
		
	引入（Introduction）p159
		切面的引入功能允许我们向现有的类添加新方法或属性。
		注：
			解析：
			当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。
			实际上，一个bean的实现被拆分到了多个类中。
		例：
			./aop引入.png
			？
	织入（Weaving）
		切面的织入功能能够为能够为现有的方法增加额外的功能

		例：
			./例子/SpringAOPAchieveSimply/
		附：
			目标对象生命周期能进行织入时间点：
				编译期：
				类加载期：
				运行期：
					切面在应用运行的某个时刻被织入。
					一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。
					Spring AOP就是以这种方式织入切面的。
			
	总结：
		切点：(通过切点来选择连接点，即)切点用于准确定位应该在什么地方应用通知。
		通知：何时要执行什么方法(切面的要完成的工作被称为通知。通知还解决了何时执行这个工作的问题(方法前置还是后置等))
		切面：包含了通知和切点的类(+切面声明注解)，这个类就是切面.
Spring实现AOP的四种方式： 
	./aop/Spring实现AOP的四种方式.txt
	
	
spring aop 原理：
	AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。
	动态代理则以Spring AOP为代表。静态代理的代表为AspectJ；
	动态代理：
		介绍：
			Spring AOP默认使用的是动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。
		动态代理实现：
            Spring AOP中的动态代理实现方式主要有两种方式，JDK动态代理和CGLIB动态代理：
                spring aop 会根据带理类的具体情况决定应用那种动态代理实现方式：
                    ./aop/ProxyFactory分析.txt
                附：
                    JDK动态代理：
                        JDK动态代理只提供接口的代理，不支持类的代理。(JDK动态代理一定要目标对象有接口，才进行代理了)
                            详：
                                SHARE_CONTENT\java基础编程\反射\javaJdk动态代理
                    CGLIB：
                        CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。
                        因为CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。
                        附：
                        为什么使用CGLIB
                            如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。
        附：？
           ./ 注解事务源码分析
	静态代理
		AspectJ使用的就是静态代理，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。
        编译阶段: java代码编译成java字节码的阶段吧！
        静态代理也是新生成一个代理类吧。所以调用时 就要调用代理类了吧！
	附：
		相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。
