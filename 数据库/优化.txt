？
	百万条数据1秒内
	冗余字段的建立，减少表之间的关联即减少数据的查询量。
	solr，mongo，redis
	Solr与MySQL查询性能对比：
		https://www.cnblogs.com/luxiaoxun/archive/2015/08/02/4696477.html
		
	加上索引比不加索引还慢：
		https://segmentfault.com/q/1010000014484036/a-1020000014484759	
		对于重复数据很多的列不合适简建立索引，因为过滤后数据量仍然很大，先走索引在走表，所以很慢


sql查询优化：
	1. 限定数据的范围.(最基础的)
			务必禁止不带任何限制数据范围条件的查询语句。
			例：
				我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；
				分页等操作。
	2.索引：
		附：
			对查询常用字段建立索引，至少提高10多倍速度。
	分析，诊断手段：
		慢查询日志：
			https://www.cnblogs.com/davidwang456/articles/9497584.html
			介绍：
				1.慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句。
					具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。
					long_query_time的默认值为10，意思是运行10S以上的语句。
				2.默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数。
				3.慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。
			注：
				如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。
		查询计划：
			EXPLAIN 命令，是 MySQL 查询优化的必备工具，可以查看SELECT语句的执行的计划。
			https://www.cnblogs.com/tufujie/p/9413852.html
			explain extended：
				https://www.cnblogs.com/duanxz/p/3564468.html
				使用该命令输出多了warning。
				这个 warning中显示了MySQL对SQL的解释，从这个解释中我们可以看到SQL的执行方式，对于分析SQL还是很有用的。
				也即explain 的extended 扩展能够在原本explain的基础上额外的提供一些查询优化的信息，这些信息可以通过mysql的show warnings命令得到。
			例子：
				https://zhuanlan.zhihu.com/p/89793056
	
大表优化
	* https://segmentfault.com/a/1190000006158186
	sql优化：https://zhuanlan.zhihu.com/p/89793056
	当MySQL单表记录数过大时，数据库的CRUD性能会明显下降.	

	1. 读/写分离
		经典的数据库拆分方案，主库负责写，从库负责读；
	2.数据库分片：
		数据库分片分为两种类型，垂直分区和水平分区.

		3.垂直分区
			根据数据库里面数据表的相关性进行拆分。 例：用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。
			总结：
				垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。
				垂直拆分优缺点：
					优点： 
						可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。
						此外，垂直分区可以简化表的结构，易于维护。
					缺点： 
						主键会出现冗余，需要管理冗余列，
						并会引起Join操作，可以通过在应用层进行Join来解决。（数据合并操作吧）
						此外，垂直分区会让事务变得更加复杂；
		4. 水平分区
			保持数据表结构不变，通过某种策略存储数据分片。
			这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 

			总结：
				水平拆分就是指数据表行的拆分。
				优缺点：
					优点：水平拆分能够 支持非常大的数据量存储，应用端改造也少
					缺点：但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂
			例：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。			
			附：
				1.表的行数超过200万行时，就会变慢。
				2.水平拆分可以支持非常大的数据量。
				3.分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。
				4.分库分表之后,全局 id 主键的处理：
					UUID：（Universally Unique Identifier通用唯一识别码）
						不适合作为主键，因为太长了，并且无序不可读，查询效率低。
						比较适合用于生成唯一的名字的标示比如文件的名字。
						什么是 UUID：https://www.jianshu.com/p/da6dae36c290	
					数据库自增 id :
						两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。
						这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
					利用 redis 生成 id :
						性能比较好，灵活方便，不依赖于数据库。
						但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
					Twitter的snowflake算法 ：
						Github 地址：https://github.com/twitter-archive/snowflake。
					美团的Leaf分布式ID生成系统 ：
						https://tech.meituan.com/2017/04/21/mt-leaf.html 。
						Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全。
	
		数据库分片的两种常见方案：

			客户端代理：
				分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。
				当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
			中间件代理：
				在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 
				我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。
		总结：
			尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 。
			一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。
			如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。
附：
	Mysql高性能优化规范建议：
		https://www.cnblogs.com/huchong/p/10219318.html
	一条SQL语句执行得很慢的原因有哪些：			
		https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd
	一条SQL语句在MySQL中如何执行的：
		https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd