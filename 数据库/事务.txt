关系型数据库:
	遵循ACID规则
事务 （transaction）：
	事务是逻辑上的一组操作，这组操作要么都执行，要么都不执行。
	spring中使用事务：	
		/spring/spring事务管理/
	事务四个特性：
		1、A (Atomicity) 原子性
			原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。
			例：比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。
			hcg：
				所有的步骤都要完成
		2、C (Consistency) 一致性

			一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。

			例：现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。
			hcg：
				操作完成后，数据的和要与操作前一致
		3、I (Isolation) 隔离性
			所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。

			例：现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。
			hcg:
				
			事务的隔离级别：
				https://blog.csdn.net/dengjili/article/details/82468576
			
		4、D (Durability) 持久性
			持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。
			hcg：
				事务提交后，其涉及的数据修改永不丢失
	事务隔离级别：
		SQL 标准定义了四个隔离级别：
			READ-UNCOMMITTED(读取未提交)： 		
				最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
			READ-COMMITTED(读取已提交)： 
				允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
			REPEATABLE-READ(可重复读)： 
				对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
			SERIALIZABLE(可串行化)： 
				最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。	
		MySQL 隔离级别：
			InnoDB 存储引擎默认支持的隔离级别是 REPEATABLE-READ。
				可以通过SELECT @@tx_isolation命令来查看;
			注：
				1.与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，
				因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。
				所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。
				
				2.因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) 。
				但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。
				
				3.InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。


附：
事务并发问题：
	多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。
	可能会导致以下的问题：
		脏读（Dirty read）: 
			当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中。
			这时另外一个事务也访问了这个数据，然后使用了这个数据。
			因为这个数据是还没有提交的数据，那么另外一个事务读到的数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
		丢失修改（Lost to modify）: 
			指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
		不可重复读（Unrepeatableread）: 
			指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
		幻读（Phantom read）: 
			幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。	
		
		不可重复读和幻读区别：
			不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。
锁机制与InnoDB锁算法：
	详细内容可以参考： MySQL锁机制简单了解一下：https://blog.csdn.net/qq_34337272/article/details/80611486
	介绍：
		MyISAM存储引擎采用表级锁(table-level locking)。
		InnoDB存储引擎支持行级锁(row-level locking)和表级锁,默认为行级锁.
	表级锁和行级锁：

		表级锁：
			MySQL中锁定 粒度最大 的一种锁。
			对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。
			其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
		行级锁： 
			MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 
			行级锁能大大减少数据库操作的冲突。
			其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

	InnoDB存储引擎的锁的算法有三种：

		Record lock：单个行记录上的锁
		Gap lock：间隙锁，锁定一个范围，不包括记录本身
			Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
			有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）
			A. 将事务隔离级别设置为RC
			B. 将参数innodb_locks_unsafe_for_binlog设置为1
		Next-key lock：record+gap 锁定一个范围，包含记录本身。
			innodb对于行的查询使用next-key lock，解决了幻读问题。
			当查询的索引含有唯一属性时，将next-key lock降级为record key