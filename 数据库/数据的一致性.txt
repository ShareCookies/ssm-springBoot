单机应用数据一致性：(或叫本地事务)
	在传统的本地事务中，为了保证数据一致性，我们只需要先开始一个事务，然后进行新增、修改、删除等操作，然后提交事务，如果发生异常就回滚。
	简简单单，就能够站在各大数据库厂商的肩膀上，实现数据一致性。
分布式事务:
	https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html
	分布式理论:
		当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区(指物理分区)，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID原则已经不能适应这种情况了。
			集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，很难扩展新的分区了等，这个时候如果再追求集群的ACID会导致我们的系统变得很差。
		这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则(或者叫CAP定理).
			附：分布式系统的最大难点，就是各个节点的状态如何同步,CAP 定理是这方面的基本定理。
		CAP定理：（CAP theorem）
			https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/
			https://zhuanlan.zhihu.com/p/50990721
			http://www.ruanyifeng.com/blog/2018/07/cap.html
			https://www.cnblogs.com/mingorun/p/11025538.html
			2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后麻省理工学院的Seth Gilbert和NancyLynch从理论上证明了CAP，之后CAP理论正式成为分布式计算领域的公认定理。
			CAP理论是由下面三个概念组成的，且在分布式系统中三者不能兼得，只能同时满足两种条件。
			CAP:
				一致性(Consistency)
					All nodes see the same data at the same time
					所有数据库集群节点在同一时间点看到的数据完全一致。即所有节点能实时保持数据同步。
				可用性(Availability)
					every request received by a non-failing node in the system must result in a response
					保证用户的每个请求不管成功或者失败都有响应
				分区容忍性(Partition tolerance)
					The system continues to operate 运转  despite  即使  arbitrary  任意的message loss or failure of part of the system
					尽管系统中有任意的信息丢失或故障，系统仍在继续运行。
					即：分区容忍性是站在分布式系统整体的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。如分布式系服务器a和分布式系服务器b，两个之间断网了，但任不影响各自的运行。
				附：
					分布式CAP定理，为什么不能同时满足三个特性
						https://blog.csdn.net/yeyazhishang/article/details/80758354
					CA、CP、AP:
						根据 CAP 原理在分布式数据库设计中，至多只能同时支持上面的两个属性。（数据分区，微服务均属分布式数据库设计）
						因此，设计人员必须在一致性与可用性之间做出选择。
						
		BASE理论：(最终一致模型)
			在分布式系统中，我们往往追求的是可用性，它的重要比一致性要高。
			那么如何实现高可用性呢，前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。
			BASE理论是对数据库可用性及一致性的弱要求原则:（常用于NoSQL等）
				Basically Availble --基本可用
				Soft-state --软状态/柔性事务。 "Soft state" 可以理解为"无连接"的, 而 "Hard state" 是"面向连接"的
				Eventual Consistency -- 最终一致性， 也是是 ACID 的最终目的。
			BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）
	分布式事务解决方案：
		一、两阶段提交（2PC Two Phase Commitment Protocol）(强一致)
			具体的分为5个步骤：
				1.应用程序调用事务协调器中的提交方法
				2.事务协调器将联络事务中涉及的每个数据库，并通知它们准备提交事务（这是第一阶段的开始）
				3.接收到准备提交事务通知后，数据库必须确保能在被要求提交事务时提交事务，或在被要求回滚事务时回滚事务。如果数据库无法准备事务，它会以一个否定响应来回应事务协调器。
				4.事务协调器收集来自各数据库的所有响应。
				5.在第二阶段，事务协调器将事务的结果通知给每个数据库。如果任一数据库做出否定响应，则事务协调器会将一个回滚命令发送给事务中涉及的所有数据库。如果数据库都做出肯定响应，则事务协调器会指示所有的资源管理器提交事务。一旦通知数据库提交，此后的事务就不能失败了。通过以肯定的方式响应第一阶段，每个资源管理器均已确保，如果以后通知它提交事务，则事务不会失败。
				附：
					在这个协议中，最关键的点就是，多个数据库的活动，均由一个事务协调器的组件来控制。
			例：
				XA Transactions
				...
		二、补偿事务（TCC）
				优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
				缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。
			例：
			分布式事务解决方案-servicecomb-pack
				在微服务系统实际开发中，如何去实现协调器以处理分布式事务呢，这里的解决方案是采用华为提供的servicecomb-pack框架来解决这一问题。
				https://mp.weixin.qq.com/s/OCxFC42l_Ug3rmUH1oCWoQ
		三、本地消息表（异步确保）
			本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。
			基本思路就是：
				消息生产方：
					需要额外建一个消息表，记录消息发送状态和一些业务信息。
					消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
				消息消费方:
					需要处理这个消息，并完成自己的业务逻辑。
					此时如果本地事务处理成功，表明已经处理成功了，更新消息表。
					如果处理失败，那么就会重试执行。
						多次失败，也发业务补偿信息吧。！
					如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。
						这里的回滚是指业务数据回滚吧，不会是一直卡着线程然后回滚吧!
					生产方或消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。
						如果多次失败，超过一定时间，可以直接回滚吧！
				这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。
				优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。
				缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。
				例：
					https://segmentfault.com/a/1190000012415698
					下面我们举个下订单的场景，总共有3个实体，商品、用户、订单
					按照user_id来sharding，所以相同user_id的用户和订单在同一个物理库下，而商品表中不存在user_id，所以商品表在不同的物理库下。

					商品、消息表
						消息表
							主要由商品ID、交易流水号、冻结数、消息状态这四个字段构成，
							冻结记录的状态有三种：已冻结、释放已售出、释放未售出。冻结记录的初始状态为已冻结。
					用户、订单
						订单的状态有三种：未支付、已支付、超时，订单的初始状态为未支付。
					订单的场景
						下，主要涉及到两个事务操作，扣减库存和生成订单，因为两个操作涉及不同的数据库，所以无法保证强一致性。

						1. 
							调用外部服务，生成全局唯一的交易流水号trans_id。
							事务一：1) 扣减库存 2) 根据流水单号，生成对应商品的冻结记录。

						因为消息表和商品表在同一个物理库下，所以TX1中的操作1和操作2是可以构成事务操作的。
						事务一如果成功，则进行事务二；如果事务一失败，则直接返回。
					事务二：根据交易流水号trans_id生成订单，
						若订单创建成功，则进行后续的支付流程。
						如果事务二失败
							事务二失败，不一定是真的生成订单失败,可能是由于网络抖动超时等原因。
							即 在事务二失败的情况下，可能生成了订单，也可能确实没有生成订单。
					定时任务一：设置一个每隔15分钟的定时任务（即一个订单必须在15分钟内完成支付），从订单表里捞出最近半小时内的所有订单，对每一个订单做如下处理：
						若订单超时未支付，开启事务SELECT FOR UPDATE 锁住该订单，即用悲观锁阻止用户对订单进行支付等操作，然后通过订单的trans_id去冻结表更新对应冻结记录的状态，置为释放未售出，并回滚商品数量，回滚商品的操作完成后，将订单状态置为超时，若事务中调用的回滚商品数量的服务失败，则可以发出报警人工处理，或通过更长时间的定时任务去处理；
						若订单为已支付，则将冻结表中记录的状态置为释放已售出。
					定时任务二：
						因为存在事务一成功，而事务二的订单确实没有创建成功的情况，这样会冻结一部分商品的数量，所以可以捞取出 创建超过10分钟 状态为已冻结的所有冻结记录，根据每个冻结记录的trans_id去订单表查询，若不存在对应的订单，则将冻结记录的状态更新为释放未售出，并回滚商品数量。

						另一个需要注意的点，在定时任务一中，对于超时未支付的订单，会先回滚冻结表，然后将订单状态置为超时，但这最后一步将订单置为超时可能会失败，这样会出现不一致的状态，即订单状态为未支付，而冻结记录的状态为释放未售出。所以，在支付的时候需要做一个前置校验，检查冻结记录的状态是否为已冻结，若不是，则拒绝支付。					
		四、MQ 事务消息
		五、Sagas 事务模型
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
废弃：
https://blog.csdn.net/u013380694/article/details/82912087
https://mp.weixin.qq.com/s?__biz=MzI5MDEzMzg5Nw==&mid=2660392782&idx=1&sn=d28e43bf6f7cf140eed9fffcf2f29e86&scene=1&srcid=0719GVTmJxt0EIHUCCt5VRuT&pass_ticket=62sxSNNbb4c5RynZPQfPfFbDs80zoGRU7eQWI84tsKNOI08773ppKTq6%2BIQFTHcv#rd
微服务架构数据一致性：(或叫分布式事务)(传统分布式事务)
	背景：
		微服务的分布式事务
			微服务倡导将复杂的单体应用拆分为若干个功能简单、松耦合的服务，这样可以降低开发难度、增强扩展性、便于敏捷开发，从而被越来越多的开发者和公司推崇运用。但系统微服务化后，一个看似简单的功能，内部可能需要调用多个服务并操作多个数据库实现，服务调用的分布式事务问题变的非常突出，几乎可以说是无法避免。
			从广义上来讲，分布式事务其实也是事务，只是区别于单机事务不同之处是：由于业务上的定义和系统微服务架构的设计，很多大型的业务流程都被拆分成了多个单一的基础服务，而为了保证每个微服务都能独立进行开发和部署运行，通常都会采用一个微服务一个数据库的架构配套，然后将内部服务进行封装，以Rest api方式对外暴露。
			这样以往基于数据库来实现的数据操作，就变成了多个对外提供微服务的微服务系统之间的协同操作。在这种情况下，原有的单机事务方式已经不能够使用了，因为多个服务就意味着存在多个事务管理器和多个资源，单个微服务的本地事务管理器只能保证本地事务的ACID，为了在多个服务之间能保证业务的事务性，参与分布式事务的微服务通常会依托协调器来完成相关的一致性协调操作。
	介绍：
		微服务中出现需要同时访问多个数据库的情况。
		此时就需要分布式事务来保证数据一致性，也就是常说的两阶段提交协议（2PC，Two Phase Commitment Protocol）。
		具体的分为5个步骤：
			1.应用程序调用事务协调器中的提交方法
			2.事务协调器将联络事务中涉及的每个数据库，并通知它们准备提交事务（这是第一阶段的开始）
			3.接收到准备提交事务通知后，数据库必须确保能在被要求提交事务时提交事务，或在被要求回滚事务时回滚事务。如果数据库无法准备事务，它会以一个否定响应来回应事务协调器。
			4.事务协调器收集来自各数据库的所有响应。
			5.在第二阶段，事务协调器将事务的结果通知给每个数据库。如果任一数据库做出否定响应，则事务协调器会将一个回滚命令发送给事务中涉及的所有数据库。如果数据库都做出肯定响应，则事务协调器会指示所有的资源管理器提交事务。一旦通知数据库提交，此后的事务就不能失败了。通过以肯定的方式响应第一阶段，每个资源管理器均已确保，如果以后通知它提交事务，则事务不会失败。
			附：
				在这个协议中，最关键的点就是，多个数据库的活动，均由一个事务协调器的组件来控制。
	附：
		传统分布式事务不是微服务中一致性的最佳选择：
		1.
			首先，对于微服务架构来说，数据访问变得更加复杂，这是因为数据都是微服务私有的，唯一可访问的方式就是通过API。这种打包数据访问方式使得微服务之间松耦合，并且彼此之间独立非常容易进行性能扩展。
		2.
			其次，不同的微服务经常使用不同的数据库。应用会产生各种不同类型的数据，关系型数据库并不一定是最佳选择。
			例如，某个产生和查询字符串的应用采用Elasticsearch的字符搜索引擎；某个产生社交图片数据的应用可以采用图数据库，例如，Neo4j；
		3.
			基于微服务的应用一般都使用SQL和NoSQL结合的模式。但是这些非关系型数据大多数并不支持2PC。
			可见在微服务架构中已经不能选择分布式事务了。
	分布式事务实战：
*微服务架构数据最终一致性：(微服务中一致性的最佳选择)
	介绍：
		1.CAP理论：任何分布式系统只可同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）中的两点。
		2.分区容错性是基本要求，可用性一般是较好的选择。
		附：满足一致性要付出阻塞其他并发访问的代价，这需要一个不确定的时间。
		3.但是在服务和数据库之间维护数据一致性是非常根本的需求，因此微服务架构中选择满足最终一致性。
		附：最终一致性是指系统中的所有数据副本经过一段时间后，最终能够达到一致的状态。一段时间是指用户可接受范围内的一段时间。
	微服务架构实现最终一致性的三种模式：	
		可靠事件模式：...
		业务补偿模式：...
		TCC模式（Try-Confirm-Cancel）：...