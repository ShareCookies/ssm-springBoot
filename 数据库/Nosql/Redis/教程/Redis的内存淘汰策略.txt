https://zhuanlan.zhihu.com/p/105587132
过期策略：
	Redis中同时使用了定期过期和惰性过期两种过期策略。
	定期删除
		redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。
		Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。
			1.从过期字典中随机 20 个 key；
			2.删除这 20 个 key 中已经过期的 key；
			3.如果过期的 key 比率超过 1/4，那就重复步骤 1；
				// 1/4是暂居总数的吗？
				那内存不够的时候:
					goto:淘汰策略
	惰性删除
		所谓惰性策略就是在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。
淘汰策略：
	为什么需要淘汰策略
		因为redis的过期策略不是精准的删除(会存在key没有被删除掉的场景),且Redis有内存大小限制，
		那在内存用完的时候，还继续往Redis里面添加数据不就没内存可用了会出现异常，因此Redis定义了几种内存淘汰策略用来处理这种情况。
		附：
			如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存
	内存淘汰策略
		1. noeviction(无受害者no eviction)(默认策略)：当内存不足以容纳新写入数据时，新写入操作会报错(返回错误)，不会驱逐任何键。
		2. allkeys-lru(Least Recently Used最近最少使用)(最常用)：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键
		3. volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键
		4. allkeys-random：加入键的时候如果过限，从所有key随机删除
		5. volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐
		6. volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键
		7. volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
		8. allkeys-lfu：从所有键中驱逐使用频率最少的键
总结：
	内存淘汰策略用于处理内存不足时，新插入数据的处理；
	过期策略用于处理过期的缓存数据。
	Redis的内存淘汰策略的选取并不会影响过期的key的处理。
