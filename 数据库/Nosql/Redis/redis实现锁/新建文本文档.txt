http://192.168.210.158:6063/project/2020/zj-housing/03-%E9%A1%B9%E7%9B%AE%E5%AE%9A%E5%88%B6/redisLock/redisLock.html
基于redis的锁实现，能自动释放锁，为有竞争的业务场景提供锁服务；
如，有一人打开文档编辑时，其它人打开提示文档其它人正在编辑。
优点：

	这个锁能保证：在没有人拿到锁的情况下，多人竞争同一锁，最后只有一人拿到。
缺陷:

	拿到锁后，业务得在过期时间内完成操作。
		即保证锁时间大于业务执行时间：
			加锁成功后，启动一条守护线程，守护线程给锁进行无限续期。
			当锁不存在的时候就跳过，存在就续期，可以保证锁的时间大于业务时间。
				附：
					线程为守护线程的原因是，守护线程依赖于主线程，当主线程挂了之后，守护线程也会挂掉！这样能避免程序宕机之后，续期的线程依旧续期，造成死锁！
					主线程是指一个正常线程吧！那守护线程是依赖于main还是这个正常线程了？应该是这个正常线程		
	拿到锁后，没释放锁的情况下，在过期时间内，再去拿锁，过期时间还是从第一次开始算。
	释放锁是没有做事务，有极小概率删除他的人锁。
		单台redis可以参考eval函数+lua脚本。
		或保证，删锁过程中，锁不会过期呗。
	拿到锁后，没释放锁的情况下，在过期时间内，再去获取锁，有极小概率锁被两个人获得。
		


