https://blog.csdn.net/miss1181248983/article/details/90056960
https://blog.csdn.net/u013058742/article/details/80004893
Redis有三种集群模式，分别是：主从模式，Sentinel模式，Cluster模式
Redis不同集群方案优缺点分析：
	https://www.cnblogs.com/johnvwan/p/12083024.html
springBoot哨兵主从：
	https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:sentinel
主从模式：
	在主从主从模式中，数据库分为两类：主数据库(master)和从数据库(slave)。
	主从复制特点：
		* 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库
		* 从数据库一般都是只读的，并且接收主数据库同步过来的数据
		* 一个master可以拥有多个slave，但是一个slave只能对应一个master
		* slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来
		* master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务
		安全设置：
			当master节点设置密码后，
			客户端访问master需要密码
			启动slave需要密码，在配置文件中配置即可
			客户端访问slave不需要密码
	工作机制：
		当slave启动后，主动向master发送SYNC命令。
		master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。
		slave接收到快照文件和命令后加载快照文件和缓存的执行命令。
		复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。
	主从模式搭建
		环境准备：
			master节点                  192.168.30.128
			slave节点                   192.168.30.129
			slave节点                   192.168.30.130
		全部下载安装：
			# cd /software
			# wget http://download.redis.io/releases/redis-5.0.4.tar.gz
			# tar zxf redis-5.0.4.tar.gz && mv redis-5.0.4/ /usr/local/redis
			# cd /usr/local/redis && make && make install
			# echo $?
		（附）全部配置成服务：
			服务文件
				# vim /usr/lib/systemd/system/redis.service
				[Unit]
				Description=Redis persistent key-value database
				After=network.target
				After=network-online.target
				Wants=network-online.target
				[Service]
				ExecStart=/usr/local/bin/redis-server /usr/local/redis/redis.conf --supervised systemd
				ExecStop=/usr/libexec/redis-shutdown
				Type=notify
				User=redis
				Group=redis
				RuntimeDirectory=redis
				RuntimeDirectoryMode=0755
				[Install]
				WantedBy=multi-user.target
		修改配置：
			192.168.30.128
				# mkdir -p /data/redis
				# vim /usr/local/redis/redis.conf
				bind 192.168.30.128               #监听ip，多个ip用空格分隔
				daemonize yes               #允许后台启动
				logfile "/usr/local/redis/redis.log"                #日志路径
				dir /data/redis                 #数据库备份文件存放目录
				#masterauth 123456               #slave连接master密码，master可省略
				#requirepass 123456              #设置master连接密码，slave可省略
				appendonly yes                  #在/data/redis/目录生成appendonly.aof文件，将每一次写操作请求都追加到appendonly.aof 文件中
				# echo 'vm.overcommit_memory=1' >> /etc/sysctl.conf
				# sysctl -p
			192.168.30.129
				# mkdir -p /data/redis
				# vim /usr/local/redis/redis.conf
				bind 192.168.30.129
				daemonize yes
				logfile "/usr/local/redis/redis.log"
				dir /data/redis
				replicaof 192.168.30.128 6379
				#masterauth 123456
				#requirepass 123456
				appendonly yes
				# echo 'vm.overcommit_memory=1' >> /etc/sysctl.conf
				# sysctl -p
			192.168.30.130
				# mkdir -p /data/redis
				# vim /usr/local/redis/redis.conf
				bind 192.168.30.130
				daemonize yes
				logfile "/usr/local/redis/redis.log"
				dir /data/redis
				replicaof 192.168.30.128 6379
				#masterauth 123456
				#requirepass 123456
				appendonly yes
				# echo 'vm.overcommit_memory=1' >> /etc/sysctl.conf
				# sysctl -p
		全部启动redis：
			# systemctl start redis
		查看集群状态：
			./src/redis-cli -p 6379 -a 密码
			info replication		
		测试：
			可以看到，在master节点写入的数据，很快就同步到slave节点上，而且在slave节点上无法写入数据。
Sentinel模式
	Sentinel模式介绍
		主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，因此sentinel应运而生。
		sentinel模式的作用就是监控redis集群的运行状况，是建立在主从模式的基础上。
		当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改。
			比如
				slaveof属性会指向新的master，
				当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，
			当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据
		sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群
			多sentinel配置的时候，sentinel之间也会自动监控
			一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis
		当使用sentinel模式的时候，客户端就不要直接连接Redis，而是连接sentinel的ip和port，由sentinel来提供具体的可提供服务的Redis实现。
			这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。
	
	工作机制：
		* 每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令 
		* 如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。 
		* 如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态
		* 当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线 
			* 在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令 
		* 当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次 
			* 若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；
			若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除
	配置文件：
		配置一个或多个sentinel
		例：
			./redis-he-sentinel.conf
	全部启动sentinel：
		./redis-server sentinel.conf --sentinel
	测试：
		将master服务杀死
			kill -15 pid
			再观察一段时间，slave从服务器成为主服务器