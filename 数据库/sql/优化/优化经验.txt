UNION优化改进：
	使用 UNION 执行计划：
		介绍：
			使用 UNION 执行计划中出现了第三条记录，其Extra 中会出现 Using temporary。
			说明 MySQL因为不能有效利用索引，建立了内部临时表来执行查询。
		附：
			当你在使用 DISTINCT 、GROUP BY、UNION等子句中的查询过程中，都有可能会出现该扩展信息。

		？
			同样临时表，为什么DISTINCT +union all 会比union 好些(4w数据少400ms)
	改成UNION ALL执行计划：
		执行结果中不再出现内部临时表(无第三条记录)。
	
	？
		为什么union 会有临时表， union all 不会有了。
	？Union会对字段进行排序：
		Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。
	mysql unionall union 原理：
		？
子查询?
	select * from () test
	explain中多了一个记录，但没有用到临时表，为什么时间还是会多了10倍。
	
为什么建议使用自增主键：
	https://blog.csdn.net/weixin_36070797/article/details/113911317
	
	主要是由于 MySQL B+ 树索引性质决定的，数据的新增是要更新索引的，也就是要更新 B+ 树。
		换句话说，使用自增Id 和 非自增 Id 哪种更新 B+ 树更快，成本更低，谁就是更优的选择。
	例：
	自增Id 插入情况： 
		我们在一个已经有10条数据的 B + 数上插入2条数据，分别是10和11，我们看看树是如何变化的。
		图：
			...
		我们这里可以发现两个特点：

		1、自增的数据插入影响的范围永远只有最右的子树，要么直接在子树插入节点，
		要么就是子树分裂，影响其父节点。?

		2、除了最右子树，其他子树的节点都是满的。

		上面两个特点有什么影响呢？
		我们根据前面 B+ 树索引示意图可以知道，每个点都是一个磁盘块，操作每个节点相当于进行一次 IO,由于每次插入影响的节点只有最右子树，那么磁盘 IO 的范围就可控；最重要一点是除最右子树，其他子树的节点都是满的，这种情况，叶子节点数据的物理连续性会更好， 根据局部性原理,查询性能也会更高。