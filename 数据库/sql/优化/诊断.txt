问题定位：
	首先你要定位到问题所在：
		1.网络问题（访问到应用的过程问题）
			诊断方式：
				方式1：换终端换网段等进行快速测试
				方式2：tracert、ping等命令测试
		2.应用问题，
			追踪方向：
				1.应用并发量过大
					附：跟cpu有关，通常tomcat并发量200为佳
				2.应用性能（服务器cpu，内存，io，进程等）
					附：看代码逻辑中是否有大I/O,高强度计算，大并发
				...
		3.数据库问题。
			诊断方式：
				并发模拟或实际情况下，通过下面的追踪方向来诊断。
			追踪方向：
				1.锁等待（如果数据库性能消耗不高，此时通过事务等来判断是否锁问题导致慢sql。）
					介绍:
						../事务/锁机制.txt
					诊断方式：
						查询正在执行的事务：SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX\G（推荐mysql客户端执行\G便于复制出来查看）
						../事务/释放锁.txt
					解决方案：
						goto：../事务/锁机制.txt InnoDB行锁优化建议
				2.数据库性能不够（优先看数据库性能，因为诊断较快。）
					诊断方式：
						1. 监控服务器性能：
							使用top等命令监控linux服务器性能。（cpu，内存，平均负载，进程占用资源情况...）
						附 2. 数据库连接数是否充足
							Navicat Monitor
						附 3. 查看数据库线程情况： 
							https://www.cnblogs.com/duhuo/p/5678286.html
							通过 show processlist 来判断数据库性能，连接数，慢sql堆积，网络状况等各种情况...
							附：
								https://www.cnblogs.com/remember-forget/p/10400496.html
								https://blog.csdn.net/dhfzhishi/article/details/81263084
								https://www.cnblogs.com/hixiaowei/p/10934484.html
						以上诊断方式通常结合起来使用，1快速看服务器性能，2提到的工具操作简单，3综合能力较强。
							
						附：
							Navicat Monitor等监控工具。
					解决方案：
						1.增加性能：
							1. 服务器太low，换更好服务器
							2. 闭眼开始集群或读写分离。
						2.sql优化（问题优化）：
							先找出导致问题的sql语句，例有问题的时间段有那些慢sql等。
							诊断方式：
								1：并发模拟，或发生问题时现场诊断。
									附：
									并发模拟工具：
										https://github.com/yuyumyself/UtilsProject/blob/master/Utils/src/main/java/com/china/hcg/thread/ThreadPoolUtilsDemo.java
								2.
									通过druid（判断那个类型sql慢），mysql慢查询（具体是那个sql慢，有参数的）等来判断是那个sql有问题。
							解决方案：
								1.走缓存
									附：缓存部分清空。失效后能否在业务低峰期在重新加载Redis缓存。
								2.优化代码逻辑，根据所需数据，看看能否少掉这个sql或少掉部分sql。
								3.sql优化：
									1. 通过explain优化sql，尽量全部走索引。
									2. 少关联表，不要超过3个表的多表关联。
										关联越多，影响因素越多，且数据量是递增级别。
									3. 复杂sql拆分成多个SQL查询。
										这样可以避免语句相互之间影响。
										让语句简洁易懂，好维护才是王道。
									4. 通过程序把查询结果带入，通过程序合并sql结果，让程序来负担一部分数据库压力。							
		例：
			例1接口大并发时慢：
				1. 是没问题的
				2. 应用也是不会有问题的，应用服务器性能稳定，且代码逻辑中没有什么大io操作，或计算等耗时操作等。
				3. 那么问题应该就是数据库层面问题。
				思路：
					优先看数据库性能，因为诊断较快。
					druid清空，开启慢sql，然后并发模拟。
					发现数据库性能消耗是较高，且druid（判断那个类型sql慢）和慢sql（具体是那个sql慢，有参数的）中均发现大量耗时sql。（这种情况实际环境中更为明显）
					因为均为查询接口，所以无需关心锁的问题，那么此时就尽量进行查询sql优化来进行初步调整。结果并发模拟和实际是得到了不错结果。
					如果未得到较好结果在尝试缓存，代码逻辑优化，集群等方案，因为问题总得解决如果不解决直接上这些方案，只是进行了问题掩盖，雷还是在的。
				附：
					1. 为什么只是查询sql无需关心锁问题：
						因为只是查询，那么也只会加共享锁才对，而共享锁下查询可以并发。
						附：
							要查询的数据，被别的给加了排他锁。
							如果是这种情况，那么就要整个应用查找哪里会有更新语句，然后尽量缩小其锁定范围。
					2. 大量慢SQL堆积导致CPU资源打满，整体数据库的性能下降。
						当未走索引或多表关联等进行大量查询时，此时数据库会调用cpu资源在硬盘中进行大量的io操作和查询，这是很耗费系统资源的。
				附（废弃）：
					接口的核心sql语句单独执行发现并没有很慢，那么此时可得到什么结论了：
						嗯，核心接口表并没有被锁。但数据库性能不够并不能完全排除
			例2：
				https://blog.csdn.net/weixin_41715077/article/details/102607330
	附：
		druid：
			druid是一个JDBC组件，它包含了数据库连接池和数据库访问性能监控等。
			在监控页面中我们可以看到：请求耗时（一个请求到应用后面的耗时），sql耗时等。
			监控页面：
				http://ip:端口/druid/ 
		如何诊断页面为何加载慢：
			统计打开页面耗时：
				如果页面打开慢，那么就看下打开这个页面要那些请求，然后看下这些请求的发起与加载时间，然后统计最终要加载的耗时。
			统计方式：	
				可在谷歌的network那条时间轴上滑动来快速的确认请求的发起顺序和时间。
				例：
					阅办单的载是跟这三个请求有关，根据各种手段分辨出 1完-2完（1结束开才始）-3完（2结束开才始），最终3个请求加起来计算出页面耗时。

sql问题诊断：
	查询问题：
		1.先找出那个sql慢。
		查看方式：
			1.通过druid等看出那个sql查询慢。
			2.开启mysql慢查询日志，找出那个sql查询慢。
		附：
			慢查询日志
				https://www.cnblogs.com/davidwang456/articles/9497584.html
				介绍：
					1.慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句。
						具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。
						long_query_time的默认值为10，意思是运行10S以上的语句。
					2.默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数。
					3.慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。
				注：
					如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。
					1.开启慢查询日志
						查看是否开启：show variables like '%slow_query_log%';
						开启慢查询日志：set global slow_query_log=1;（重启后失效）；
					2.设置慢查询日志
						设置阀值时长命令：set global long_query_time=3   （修改为阀值到3秒钟的就是慢sql）（500ms）
		
		2.分析sql慢原因：
			查询计划：
				https://www.cnblogs.com/tufujie/p/9413852.html
				https://blog.csdn.net/liufuchun111/article/details/85166481
				介绍：
					EXPLAIN 命令，是 MySQL 查询优化的必备工具，可以查看SELECT语句的执行的计划。
						mysql的执行计划查看相对oracle简便很多,功能也相对简单很多。
					explain extended：
						https://www.cnblogs.com/duanxz/p/3564468.html
						使用该命令输出多了warning。
						这个 warning中显示了MySQL对SQL的解释，从这个解释中我们可以看到SQL的执行方式，对于分析SQL还是很有用的。
				附：
				执行计划结果的查看：
					1. id
						id列数字越大越先执行。
						如果说数字一样大,那么就从上往下依次执行,id列为null的就表是这是一个结果集,不需要使用它来进行查询。
					 
					2. select_type
						select_type列常见的有：
							A:simple:表示不需要union操作或者不包含子查询的简单select查询。有连接查询时,外层的查询为simple,且只有一个
							B:primary:一个需要union操作或者含有子查询的select,位于最外层的单位查询的select_type即为primary。且只有一个
							C:union:union连接的两个select查询,第一个查询是dervied派生表,除了第一个表外,第二个以后的表select_type都是union
							D:dependent union:与union一样,出现在union 或union all语句中,但是这个查询要受到外部查询的影响
							E:union result:包含union的结果集,在union和union all语句中,因为它不需要参与查询,所以id字段为null
							F:subquery:除了from字句中包含的子查询外,其他地方出现的子查询都可能是subquery
							G:dependent subquery:与dependent union类似,表示这个subquery的查询要受到外部表查询的影响
							H:derived:from字句中出现的子查询,也叫做派生表,其他数据库中可能叫做内联视图或嵌套select
					 
					3. table
						显示的查询表名。
						如果查询使用了别名,那么这里显示的是别名,如果不涉及对数据表的操作,那么这显示为null,如果显示为尖括号括起来的 就表示这个是临时表,后边的N就是执行计划中的id,表示结果来自于这个查询产生。如果是尖括号括起来的 ,与 类似,也是一个临时表,表示这个结果来自于union查询的id为M,N的结果集。
					 
					*4. type 
						介绍：
							该sql语句查询使用的索引类型。
							依次从好到差:system,const,eq_ref,ref,fulltext,ref_or_null,unique_subquery,index_subquery,range,index_merge,index,ALL。
							除了all之外,其他的type都使用到索引,除了index_merge之外,其他的type只可以用到一个索引
						type值：
							A:system:
								表中只有一行数据或者是空表,且只能用于myisam和memory表。如果是Innodb引擎表,type列在这个情况通常都是all或者index
							B:const:
								使用唯一索引或者主键,返回记录一定是1行记录的等值where条件时,通常type是const。其他数据库也叫做唯一索引扫描
							C:eq_ref:
								出现在要连接过个表的查询计划中,驱动表只返回一行数据,且这行数据是第二个表的主键或者唯一索引,且必须为not null,唯一索引和主键是多列时,只有所有的列都用作比较时才会出现eq_ref
							D:ref:
								不像eq_ref那样要求连接顺序,也没有主键和唯一索引的要求,只要使用相等条件检索时就可能出现,常见与辅助索引的等值查找。或者多列主键、唯一索引中,使用第一个列之外的列作为等值查找也会出现,总之,返回数据不唯一的等值查找就可能出现。
							E:fulltext:
								全文索引检索,要注意,全文索引的优先级很高,若全文索引和普通索引同时存在时,mysql不管代价,优先选择使用全文索引
							F:ref_or_null:
								与ref方法类似,只是增加了null值的比较。实际用的不多。
							G:unique_subquery:
								用于where中的in形式子查询,子查询返回不重复值唯一值
							H:index_subquery:
								用于in形式子查询使用到了辅助索引或者in常数列表,子查询可能返回重复值,可以使用索引将子查询去重。
							I:range:
								索引范围扫描,常见于使用>,<,is null,between ,in ,like等运算符的查询中。
							J:index_merge:
								表示查询使用了两个以上的索引,最后取交集或者并集,常见and ,or的条件使用了不同的索引,官方排序这个在ref_or_null之后,但是实际上由于要读取所个索引,性能可能大部分时间都不如range
							K:index:
								索引全表扫描,把索引从头到尾扫一遍,常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。
							L:all:
								这个就是全表扫描数据文件,然后再在server层进行过滤返回符合要求的记录。
						 
					5. possible_keys
						查询可能使用到的索引都会在这里列出来
					 
					*6. key
						查询真正使用到的索引,select_type为index_merge时,这里可能出现两个以上的索引,其他的select_type这里只会出现一个。
					 
					7. key_len
					用于处理查询的索引长度,如果是单列索引,那就整个索引长度算进去,如果是多列索引,那么查询不一定都能使用到所有的列,具体使用到了多少个列的索引,这里就会计算进去,没有使用到的列,这里不会计算进去。留意下这个列的值,算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意,mysql的ICP特性使用到的索引不会计入其中。另外,key_len只计算where条件用到的索引长度,而排序和分组就算用到了索引,也不会计算到key_len中。
					 
					8. ref
					如果是使用的常数等值查询,这里会显示const,如果是连接查询,被驱动表的执行计划这里会显示驱动表的关联字段,如果是条件使用了表达式或者函数,或者条件列发生了内部隐式转换,这里可能显示为func
					 
					*9. rows
						这里是执行计划中估算的扫描行数,不是精确值
					 
					10. extra
					这个列可以显示的信息非常多,有几十种,常用的有
					A:distinct:在select部分使用了distinc关键字
					B:no tables used:不带from字句的查询或者From dual查询
					C:使用not in()形式子查询或not exists运算符的连接查询,这种叫做反连接。即,一般连接查询是先查询内表,再查询外表,反连接就是先查询外表,再查询内表。
					D:using filesort:排序时无法使用到索引时,就会出现这个。常见于order by和group by语句中
					E:using index:查询时不需要回表查询,直接通过索引就可以获取查询的数据。
					F:using join buffer(block nested loop),using join buffer(batched key accss):5.6.x之后的版本优化关联查询的BNL,BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。
					G:using sort_union,using_union,using intersect,using sort_intersection:
					using intersect:表示使用and的各个索引的条件时,该信息表示是从处理结果获取交集
					using union:表示使用or连接各个使用索引的条件时,该信息表示从处理结果获取并集
					using sort_union和using sort_intersection:与前面两个对应的类似,只是他们是出现在用and和or查询信息量大时,先查询主键,然后进行排序合并后,才能读取记录并返回。
					H:using temporary:表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表,执行计划中看不出来,需要查看status变量,used_tmp_table,used_tmp_disk_table才能看出来。
					I:using where:表示存储引擎返回的记录并不是所有的都满足查询条件,需要在server层进行过滤。查询条件中分为限制条件和检查条件,5.6之前,存储引擎只能根据限制条件扫描数据并返回,然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性,可以把检查条件也下推到存储引擎层,不符合检查条件和限制条件的数据,直接不读取,这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition
					J:firstmatch(tb_name):5.6.x开始引入的优化子查询的新特性之一,常见于where字句含有in()类型的子查询。如果内表的数据量比较大,就可能出现这个
					K:loosescan(m..n):5.6.x之后引入的优化子查询的新特性之一,在in()类型的子查询中,子查询返回的可能有重复记录时,就可能出现这个
					 
					除了这些之外,还有很多查询数据字典库,执行计划过程中就发现不可能存在结果的一些提示信息
					 
					11. filtered
						5.7前使用explain extended时会出现这个列,5.7之后的版本默认就有这个字段,不需要使用explain extended了。
						这个字段表示存储引擎返回的数据在server层过滤后,剩下多少满足查询的记录数量的比例,注意是百分比,不是具体记录数。

				例：
					https://zhuanlan.zhihu.com/p/89793056
					例2：
						小总结：
							mysql普通查询是未加锁的。
							查询时是会用到索引的，索引的命中优化规则小总结：
								1. 用and那么会优先使用有索引的条件
								2. 用or 那么只要or条件中有非索引的，那么还是全表检索
						#主键ID 索引DOC_SEQUENCE
						EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' #type:const rows:1
						EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' AND DOC_SEQUENCE = '20190124'  #type:const rows:1
						EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR DOC_SEQUENCE = '20190124' #type:index_merge rows:2
						EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR SUBJECT = '索引性能测试' #type:ALL rows:613
						
附：
	ajax请求：
		https://zhidao.baidu.com/question/984180091419371739.html?qbl=relate_question_0&word=%C8%E7%BA%CE%B4%D3%BF%D8%D6%C6%CC%A8%D6%D0%BF%B4%B3%F6%C4%C7%D0%A9%CA%C7%CD%AC%B2%BD%C7%EB%C7%F3%BB%B9%CA%C7%D2%EC%B2%BD%C7%EB%C7%F3
		同步ajax请求不会阻塞页面，只会堵塞Ajax请求本身。
		Ajax异步和同步的区别是：
			当Ajax请求开始时，异步请求路径后，不管请求结度果，直接进行运行到下一步，相当于在Ajax时开了一个新线程；
			而同步请求时，访问请求路径后，等待请求完成，然知后在进行下一步。但是这两个请求道是不会堵塞页面本身的，click事件本身就是异步的。所以多次点击会导致请求多次。
	mysql查询缓慢原因和解决方案
		https://blog.csdn.net/weberhuangxingbo/article/details/80694045
	mysql数据库最大能支持多少并发量
		https://bbs.csdn.net/topics/380001502?page=2
		看系统支持
	查看MySQL线程
		
		show processlist 是显示用户正在运行的线程，需要注意的是，除了 root 用户能看到所有正在运行的线程外，其他用户都只能看到自己正在运行的线程，看不到其它用户正在运行的线程。除非单独个这个用户赋予了PROCESS 权限。
		例：
			查看前100条：SHOW PROCESSLIST
				

