数据查找过程：
	数据库管理系统，执行一个在Student表上根据指定的Sno，查找该学生信息的语句。
	没有索引：
		如果没有索引，则数据库管理系统需要从Student表的第一行开始，并逐行检索指定的Sno值。
		从数据结构的算法知道我们知道，有序数据的查找比无序数据的查找效率要高很多。
	有索引：
		数据库管理系统发现查找条件中有索引项，
		然后在索引表查找Sno，找到sno后根据其对应的数据的存储位置，直接检索出需要的信息。
索引介绍：
	mysql索引原理：
		./mysql索引原理.txt
	索引建设原则：
		索引创建建议：
			1．为经常需要排序、分组和联合操作的字段建立索引？
				联合： 对于两表连接的字段，应该建立索引。
				排序： 如果经常在某表的一个字段进行Order By 则也可进行索引。
			2．为常作为查询条件的字段建立索引
				通常来说查询都会用到索引，所以在WHERE和JOIN中出现的列一般都需要建立索引，
				但也不完全如此，因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。
			3. 不应该在小表上建设索引
		索引注意事项：
			优化注意事项：
			LIKE使用索引:
			  	刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。
				例:
					如下句会使用索引：
				  　　	SELECT * FROM mytable WHERE username like'admin%'
				 	而下句就不会使用：
				 　　 	SELECT * FROM mytable WHEREt Name like'%admin'
			不要在列上进行运算:
				在列上进行运算,将在每个行上进行运算，这将导致索引失效而进行全表扫描，
				select * from users where YEAR(adddate)<2007;
				因此我们可以改成
			  　　 select * from users where adddate<'2007-01-01';
				?NOW()等函数了
			and or：
				and：
					1. 用and那么会优先使用有索引的条件
				or：
					1. 用or 那么只要or条件中有非索引的，那么还是全表检索
				例：
					#主键ID 索引DOC_SEQUENCE
					EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' #type:const rows:1
					EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' AND DOC_SEQUENCE = '20190124'  #type:const rows:1
					or两个均索引：
						EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR DOC_SEQUENCE = '20190124' #type:index_merge rows:2
					or有一个非索引：
						EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR SUBJECT = '索引性能测试' #type:ALL rows:613

			使用短索引
				对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

			索引列排序

				MySQL查询只使用一个索引。
				因此如果 where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。
				因此数据库默认排序可以符合要求的情况下不要使用排序操作;
				尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
			索引不会包含有NULL值的列
				只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

			不使用NOT IN和<>操作
				https://www.cnblogs.com/gaogao67/p/11046902.html
				不使用NOT IN
					https://blog.csdn.net/liuxilil/article/details/6718409?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf
					https://blog.csdn.net/vixou/article/details/84613672
					https://blog.csdn.net/fly910905/article/details/78288685
				<>:
					https://www.v2ex.com/t/425142

				
	附：
		索引的简易简易理解：
			索引可以简单的理解为一张表，该表保存索引字段，并指向实体表的记录。
		索引优缺点:
		　	优点：索引可以极大的提高数据的查询速度。 
			缺点：
				索引会降低更新表的速度，当进行其他DML时，会更新索引文件。
				建立索引会占用磁盘空间的索引文件。
	
		索引的存储结构：
			介绍：
				MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。
				在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。
			哈希索引:
				底层的数据结构是哈希表.
			BTree索引:
				BTree按搜索关键字排序，因此可以在组成搜索关键字的，任何字词条集合上进行高效搜索。
					例：
						对一个有A,B,C三个列组成的索引，可以在A以及A,B和A,B,C上对其进行高效搜索。?
				MySQL的BTree索引使用的是B树中的B+Tree，但mysql两种主流存储引擎的BTree索引实现方式是不同的。
				InnoDB: ?
					其数据文件本身就是索引文件。
					表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。
					(MyISAM索引文件和数据文件是分离的)
					附：
						这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。
						而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。
						在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 
						因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

索引的常见操作：
	创建索引：
		https://www.cnblogs.com/tommy-huang/p/4483684.html
		MYSQL语法：	
			CREATE [UNIQUE|FULLTEXT]  INDEX <索引名> ON <表名> （列名 [,...n](length)）
				索引类型：
					NORMAL 普通索引:默认
						
					UNIQUE 唯一索引：
						表示要创建的索引是唯一索引	
						不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique
					FULLTEXT：旧版的MySQL的全文索引只能用在MyISAM表格的char、varchar和text的字段上。！！！
						表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
					SPATIAL
					注：
						索引的类别由建立索引的字段内容特性来决定。
				length：
					可以指定索引长度
						比如指定100的长度在a列上,那么就是根据a列内容的前100长度的内容去建立索引
						例：
							a列有4个值 abc,efghijkl,aa.
							a列上建立长度3的索引,那么参与建立索引的数据 abc,efg,ijk,aa
					索引长度小，有利于减小索引项空间，然后有利于减小b+树高度，最后减小搜索时io提高搜索效率。
						例：
							建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高  INSERT的更新速度。
						附：
							mysql中索引长度与区分度的选择：
								https://blog.csdn.net/heyuqing32/article/details/80966301
			例：
				CREATE UNIQUE INDEX sIndex ON Student(sname,lastName)
				附：
					？非聚集索引，聚集索引
					使用ALTER 命令添加：
						ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
						ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
						ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。
						ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。
		单列索引:
			即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
		组合索引:
			一个索引包含多个列。
			例：
				https://www.jianshu.com/p/40edfbb50046
				3个字段：name, city, age、
				如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，远低于组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。
			
				建立组合索引
					ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);
					最左前缀：
						其实是相当于分别建立了下面三组组合索引：
	 　　 					name,city,age;name,city;name;
						附：
							为什么没有 city，age组合呢。这是因为MySQL组合索引“最左前缀”的结果。
							简单的理解就是只从最左面的开始组合。
						例：
							并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：
								SELECT * FROM mytable WHREE username="admin" AND city="郑州"
								SELECT * FROM mytable WHREE username="admin"
							下面几个则不会用到：
		  　　					SELECT * FROM mytable WHREE age=20 AND city="郑州"
								SELECT * FROM mytable WHREE city="郑州"
			区别：
				https://blog.csdn.net/Abysscarry/article/details/80792876
				同时存在联合索引和单列索引（字段有重复的），这个时候查询mysql会怎么用索引呢。
					这个涉及到mysql本身的查询优化器策略了，当一个表有多条索引可走时, Mysql 根据查询语句的成本来选择走哪条索引；
				什么时候要用组合索引了：
					...
				最左前缀原则原理：
					？
	删除索引：
		语法：
			Mysql: DROP INDEX <索引名> on <表名>
			SqlServer: drop index <表名>.<索引名>
	注：
		查看表上拥有的索引：
			show index from <表名>;		


