https://dev.mysql.com/doc/refman/5.7/en/create-index.html

索引：
	介绍：
		索引的简易理解：
			索引可以简单的理解为一张表，该表保存索引字段，并指向实体表的记录。
			数据查找过程：
				数据库管理系统，执行一个在Student表上根据指定的Sno，查找该学生信息的语句。
				没有索引：
					如果没有索引，则数据库管理系统需要从Student表的第一行开始，并逐行检索指定的Sno值。
				有索引：
					数据库管理系统发现查找条件中有索引项，
					然后在索引表查找Sno，找到sno后根据其对应的数据的存储位置，直接检索出需要的信息。
		索引优缺点:
		　	优点：索引可以极大的提高数据的查询速度。 
			缺点：
				建立索引会创建占用磁盘空间的索引文件。
				索引会降低更新表的速度，当进行其他DML时，会更新索引文件。

		索引的存储结构：
			介绍：
				MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。
				mysql默认BTree索引。
			哈希索引:
				底层的数据结构是哈希表.
				优缺点:
					hash索引，等值查询效率高
					不能排序,不能进行范围查询
			BTree索引:
				介绍：
					BTree按搜索关键字排序(就是用索引构成一个b树)，因此可以在组成搜索关键字的，任何字词条集合上进行高效搜索。
						例：
							对一个有A,B,C三个列组成的索引，可以在A以及A,B和A,B,C上对其进行高效搜索。
							goto：最左前缀原则
					MySQL的BTree索引使用的是B树中的B+Tree，但mysql两种主流存储引擎的BTree索引实现方式是不同的。
				InnoDB: 
					InnoDB索引，数据文件就存储在索引上。
					即构成BTREE节点的关键字，是数据表的主键，树的叶节点保存了完整的数据记录(data域)。
					聚簇索引（或聚集索引）：（InnoDB的BTREE实现原理）
						构成BTREE索引节点的关键字是数据表的主键，叶节点则是数据文件本身。
						而其余的索引都作为辅助索引，辅助索引的叶节点(data域)存储则存储主键。
						在根据主索引搜索时，直接找到对应的叶节点数据即可；
						在根据辅助索引查找时，则需要先找到主键，再跟据主建去走一遍主索引。 
						附：
							因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键！，这样会造成主索引频繁分裂。
						？
							那主键B树所有叶节点有都读取到缓存中吗，应该没有吧，不然不是太大了
				MyIsam：
					MyISAM索引文件和数据文件是分离的
					非聚簇索引：
						goto： 非聚簇索引

				附：
				聚簇与非聚簇索引：(数据存储方式)
					https://blog.51cto.com/2839840/2057806?utm_source=oschina-app
					注：
						MyISAM采用非聚集索引，InnoDB 采用聚簇索引。
					介绍：
						我们非常容易想象出一个只有单关键字组成的表如何使用B+树进行索引，只要将关键字存储到树的节点即可。
						当数据库一条记录里包含多个字段时，一棵B+树就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。这时应该在第二个要检索的列上建立第二套索引,这个索引由独立的B+树来组织。
						?
							多字段，但又无主键了，如何组织了？
						有两种常见的方法可以解决多个B+树访问同一套表数据的问题，一种叫做聚簇索引（clustered index ），一种叫做非聚簇索引（secondary index）。
						附：
							这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。
						聚簇索引：
							对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储主键，主键和非主键B+树是两棵独立但有关联的树。
							...
							附：
								因此 InnoDB 必须要有主键？，且通过主键索引效率很高。
								但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。
								因此，主键不应该过大，因为主键太大，其他索引也都会很大。
									是指其他索引的叶节点会过大吧！
						非聚簇索引:
							对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。
							...
							主键索引和辅助索引则是完全是独立的树,各自都保存了指向数据的指针。
		mysql索引原理：
			./mysql索引原理.txt
索引优化：
	索引建设原则：(索引创建建议)
		1．为搜索条件、排序、分组、联合操作的字段建立索引.
			搜索条件: 
				为常作为查询条件的字段建立索引.
				但也不完全如此，因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。!
			联合： 对于两表连接的字段，应该建立索引。？
			排序： 如果经常在某表的一个字段进行Order By 则也可进行索引。
				那么order是什么时候排了？
			连接子句?
		2.尽量使用短索引
			对字段创建索引时，如果可能应该指定一个前缀长度。
			如此可以减小索引树高度就可减少io次数，加快了查找速度对新增更新也有利处。
			例：
				如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。
				
				短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
			原因：
				通过 ./mysql索引原理.txt 的分析，我们知道IO次数取决于b+数的高度h。
				假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，？当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。



		2．离散型越高越好：
			因为离散度越高，通过索引最终确定的范围越小，最终扫面的行数也就越少。
			？
				我很想知道比如0，1两种索引，应该是只对存储了2个指针位吧，那先找到第一个指针位数据块，这个数据块后面又跟了下一个指针位数据块吗？
			附：
				mysql中索引长度与区分度的选择：
					https://blog.csdn.net/heyuqing32/article/details/80966301

		3. 适度设置索引列
			设置索引时要考虑设置合适的列，不要造成“过多的索引列”。
			原因：	
				因为每个索引需要额外的磁盘空间，并降低写更操作的性能。
				在修改表内容的时候，索引会进行更新，更有甚至需要重构，索引列越多，所花费的时间就会越长。所以只保持需要的索引有利于查询即可。
			附：
				？是否可以建个多列索引来剔除单列索引了。
				应该还是没有理解组合索引真正的构成造成的疑问。
	索引使用注意事项：（优化注意事项）
		不使用NOT IN和<>操作!
			https://www.cnblogs.com/gaogao67/p/11046902.html
			不使用NOT IN
				https://blog.csdn.net/liuxilil/article/details/6718409?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf
				https://blog.csdn.net/vixou/article/details/84613672
				https://blog.csdn.net/fly910905/article/details/78288685
			<>:
				https://www.v2ex.com/t/425142
		LIKE使用索引:
		  	刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。
			例:
				如下句会使用索引：
			  　　	SELECT * FROM mytable WHERE username like'admin%'
			 	而下句就不会使用：
			 　　 	SELECT * FROM mytable WHEREt Name like'%admin'
		不要在列上进行运算:
			在列上进行运算,将在每个行上进行运算，这将导致索引失效而进行全表扫描，
			select * from users where YEAR(adddate)<2007;
			因此我们可以改成
		  　　 select * from users where adddate<'2007-01-01';
			?NOW()等函数了
		and or：
			and：
				1. 用and那么会优先使用有索引的条件
			or：
				1. 用or 那么只要or条件中有非索引的，那么还是全表检索
			例：
				#主键ID 索引DOC_SEQUENCE
				EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' #type:const rows:1
				EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' AND DOC_SEQUENCE = '20190124'  #type:const rows:1
				or两个均索引：
					EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR DOC_SEQUENCE = '20190124' #type:index_merge rows:2
				or有一个非索引：
					EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR SUBJECT = '索引性能测试' #type:ALL rows:613

		索引列排序
			MySQL查询只使用一个索引。
			因此如果 where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。
			因此数据库默认排序可以符合要求的情况下不要使用排序操作;！
			尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。?
		索引不会包含有NULL值的列
			只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。！



索引的常见操作：
	创建索引：
		https://www.cnblogs.com/tommy-huang/p/4483684.html
		MYSQL语法：	
			CREATE [UNIQUE|FULLTEXT]  INDEX <索引名> ON <表名> （列名 [,...n](length)）
				索引类型：
					NORMAL 普通索引:默认
						
					UNIQUE 唯一索引：
						表示要创建的索引是唯一索引	
						不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique
					FULLTEXT：？
						表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。
						用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
						注：
							旧版的MySQL的全文索引只能用在MyISAM表格的char、varchar和text的字段上。！
					SPATIAL？
					注：
						索引的类别应由索引对应字段内容特性来决定。
				length：
					可以指定索引长度
						比如指定100的长度在a列上,那么就是根据a列内容的前100长度的内容去建立索引
						例：
							a列有4个值 abc,efghijkl,aa.
							a列上建立长度3的索引,那么参与建立索引的数据 abc,efg,ijk,aa

		例：
			CREATE UNIQUE INDEX sIndex ON Student(sname,lastName)
			附：
				使用ALTER 命令添加：
					ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
					ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
					ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。
					ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。
		单列索引:
			即一个索引只包含单个列.
			附：
				一个表可以有多个单列索引：
					多个单列索引，并不是组合索引，mysql会根据情况，决定应用那些索引。
					例：
						场景：
							3个字段：nameno, city, age、
							如果分别在 nameno 建立的是唯一索引，city，age上建立普通单列索引，此时该表有3个单列索引。
						只应用了一个索引：
							使用了类似以下的查询语句：
							select * FROM UMS_LOGIN_LOG WHERE UNIT_NAME LIKE '%吕' and nameno = '1300';
							使用explain发现此时这里就只应用了一个索引nameno。
							虽然有三个索引，但MySQL内部分析后觉的只应用一个索引就能达到目的。
						查询时使用了多个单列索引，最后取交集或者并集，再去主索引查：
							select * FROM UMS_LOGIN_LOG WHERE city = 'beijing' or age = '13';
							使用explain发现为type为index_merge,索引也应用了多个。

		组合索引:
			https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html
			一个索引包含多个列。
			例：
				建立组合索引
					ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);

				https://www.jianshu.com/p/40edfbb50046
				3个字段：name, city, age、
				如果分别在 name，city，age上建立单列索引，让该表有3个单列索引，远低于组合索引。
				因为此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。
					！就是说mysql查询时只会使用一个(mysql任务效率最好的)索引吗
					应该是的
					select * FROM UMS_LOGIN_LOG WHERE UNIT_NAME LIKE '%吕' and USER_NO = '1300B00081217843';
					像这里就后一个索引

			区别：
				https://blog.csdn.net/Abysscarry/article/details/80792876
				同时存在联合索引和单列索引（字段有重复的），这个时候查询mysql会怎么用索引呢。
					这个涉及到mysql本身的查询优化器策略了，当一个表有多条索引可走时, Mysql 根据查询语句的成本来选择走哪条索引；
				什么时候要用组合索引了：
					看是否会应用到多字段查询或排序
					索引越少更新成本越低
				最左前缀原则：(索引的最左匹配特性)
					./mysql索引原理.txt goto: 索引的最左匹配特性

					介绍：
						最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。
						（关键字：最左边的为起点，连续的索引，范围查询）
							如果建立(a,b,c,d)的索引则都可以用到，a,b,c,d的顺序可以任意调整，因为优化器会自动调整顺序。。
						
					原理：
						原理图：
							https://www.cnblogs.com/lanqi/p/10282279.html
							索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。
							例：
								创建一个（a,b)的联合索引，那么它的索引树是这样的:
								./联合索引B树.png
								以a为核心构成了一个b树。
									可以看到 a的值是有顺序的 1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。
									所以b = 2这种查询条件没有办法利用索引。
								a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。
									所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。
									所以：
										a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的。
										而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。
											此处a找完后，b因为无序所以只能遍历，b其实就没用上索引，所以为什么叫遇上范围查询就会停止。
								！
									如果是a，b，c。那我 a = 1 and c = 2 也能用上索引吧，因为我觉的a有序下，c也有序。
									答案要研究下a，b，c的索引构成。或实操看下。
									
									答：错
										https://blog.csdn.net/sinat_41917109/article/details/88944290
										select * from table_name where a = '1' and c = '3' 
										如果不连续时，只用到了a列的索引，b列和c列都没有用到 
						当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，
							比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；
							但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。
							比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。
						!:
							a,b,c联合索引，a，b

					
	删除索引：
		语法：
			Mysql: DROP INDEX <索引名> on <表名>
			SqlServer: drop index <表名>.<索引名>
	注：
		查看表上拥有的索引：
			show index from <表名>;		


