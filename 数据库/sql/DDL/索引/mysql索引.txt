https://dev.mysql.com/doc/refman/5.7/en/create-index.html
数据查找过程：
	数据库管理系统，执行一个在Student表上根据指定的Sno，查找该学生信息的语句。
	没有索引：
		如果没有索引，则数据库管理系统需要从Student表的第一行开始，并逐行检索指定的Sno值。
		从数据结构的算法知道我们知道，有序数据的查找比无序数据的查找效率要高很多。
	有索引：
		数据库管理系统发现查找条件中有索引项，
		然后在索引表查找Sno，找到sno后根据其对应的数据的存储位置，直接检索出需要的信息。
索引：
	介绍：
		索引的简易简易理解：
			索引可以简单的理解为一张表，该表保存索引字段，并指向实体表的记录。
		索引优缺点:
		　	优点：索引可以极大的提高数据的查询速度。 
			缺点：
				建立索引会创建占用磁盘空间的索引文件。
				索引会降低更新表的速度，当进行其他DML时，会更新索引文件。
		mysql索引原理：
			./mysql索引原理.txt
		索引的存储结构：
			介绍：
				MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。
				建议选择BTree索引。
			哈希索引:
				底层的数据结构是哈希表.
				附：
					hash索引，等值查询效率高，不能排序,不能进行范围查询
			BTree索引:
				BTree按搜索关键字排序(就是用索引构成一个b树)，因此可以在组成搜索关键字的，任何字词条集合上进行高效搜索。
					例：
						对一个有A,B,C三个列组成的索引，可以在A以及A,B和A,B,C上对其进行高效搜索。
						即最左原则
				MySQL的BTree索引使用的是B树中的B+Tree，但mysql两种主流存储引擎的BTree索引实现方式是不同的。
				InnoDB: ？
					其数据文件本身就是索引文件。
					表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。
					(MyISAM索引文件和数据文件是分离的)
					附：
						这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。
						而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。
						在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 
						因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。
				MyIsam：
		聚簇与非聚簇索引：(数据存储方式)
			https://blog.51cto.com/2839840/2057806?utm_source=oschina-app
			注：
				MyISAM采用非聚集索引，InnoDB 采用聚簇索引。
			介绍：
				我们非常容易想象出一个只有单关键字组成的表如何使用B+树进行索引，只要将关键字存储到树的节点即可。当数据库一条记录里包含多个字段时，一棵B+树就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。这时应该在第二个要检索的列上建立第二套索引。  这个索引由独立的B+树来组织。
			
				有两种常见的方法可以解决多个B+树访问同一套表数据的问题，一种叫做聚簇索引（clustered index ），一种叫做非聚簇索引（secondary index）。
				这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。
				聚簇索引：
					对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。
					...
					附：
						因此 InnoDB 必须要有主键，且通过主键索引效率很高。
						但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。
						因此，主键不应该过大，因为主键太大，其他索引也都会很大。！
				非聚簇索引:
					对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。
					...
					主键索引和辅助索引是独立的,各自都保存了指向数据的指针。
	索引建设原则：(索引创建建议)
		1．为搜索条件、排序、分组、联合操作的字段建立索引.
			搜索条件: 
				为常作为查询条件的字段建立索引.
				但也不完全如此，因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。!
			联合： 对于两表连接的字段，应该建立索引。!
			排序： 如果经常在某表的一个字段进行Order By 则也可进行索引。
				那么order是什么时候排了？
			连接子句?
		2．离散型越高越好：
			因为离散度越高，通过索引最终确定的范围越小，最终扫面的行数也就越少。
			
				我很想知道比如0，1两种索引，应该是只对存储了2个指针位吧，那先找到第一个指针位数据块，这个数据块后面又跟了下一个指针位数据块吗？
		3. 适度设置索引列
			设置索引时要考虑设置合适的列，不要造成“过多的索引列”。
				因为每个索引需要额外的磁盘空间，并降低写操作的性能。并且在修改表内容的时候，索引会进行更新，更有甚至需要重构，索引列越多，所花费的时间就会越长。所以只保持需要的索引有利于查询即可。
			？是否可以建个多列索引来剔除单列索引了。
			应该还是没有理解组合索引真正的构成造成的疑问。
	索引注意事项：（优化注意事项）
		不使用NOT IN和<>操作!
			https://www.cnblogs.com/gaogao67/p/11046902.html
			不使用NOT IN
				https://blog.csdn.net/liuxilil/article/details/6718409?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf
				https://blog.csdn.net/vixou/article/details/84613672
				https://blog.csdn.net/fly910905/article/details/78288685
			<>:
				https://www.v2ex.com/t/425142
		LIKE使用索引:
		  	刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。
			例:
				如下句会使用索引：
			  　　	SELECT * FROM mytable WHERE username like'admin%'
			 	而下句就不会使用：
			 　　 	SELECT * FROM mytable WHEREt Name like'%admin'
		不要在列上进行运算:
			在列上进行运算,将在每个行上进行运算，这将导致索引失效而进行全表扫描，
			select * from users where YEAR(adddate)<2007;
			因此我们可以改成
		  　　 select * from users where adddate<'2007-01-01';
			?NOW()等函数了
		and or：
			and：
				1. 用and那么会优先使用有索引的条件
			or：
				1. 用or 那么只要or条件中有非索引的，那么还是全表检索
			例：
				#主键ID 索引DOC_SEQUENCE
				EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' #type:const rows:1
				EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' AND DOC_SEQUENCE = '20190124'  #type:const rows:1
				or两个均索引：
					EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR DOC_SEQUENCE = '20190124' #type:index_merge rows:2
				or有一个非索引：
					EXPLAIN SELECT * FROM EGOV_RECEIVAL WHERE id = 'XYCtqoSukpvSznD2' OR SUBJECT = '索引性能测试' #type:ALL rows:613

		使用短索引
			对串列进行索引，如果可能应该指定一个前缀长度。（节省索引空间，和索引树高度减少io次数）
				例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

		索引列排序
			MySQL查询只使用一个索引。
			因此如果 where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。
			因此数据库默认排序可以符合要求的情况下不要使用排序操作;！
			尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。?
		索引不会包含有NULL值的列
			只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。！



索引的常见操作：
	创建索引：
		https://www.cnblogs.com/tommy-huang/p/4483684.html
		MYSQL语法：	
			CREATE [UNIQUE|FULLTEXT]  INDEX <索引名> ON <表名> （列名 [,...n](length)）
				索引类型：
					NORMAL 普通索引:默认
						
					UNIQUE 唯一索引：
						表示要创建的索引是唯一索引	
						不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique
					FULLTEXT：
						表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。
						用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
						注：
							旧版的MySQL的全文索引只能用在MyISAM表格的char、varchar和text的字段上。！！！
					SPATIAL
					注：
						索引的类别由建立索引的字段内容特性来决定。
				length：
					可以指定索引长度
						比如指定100的长度在a列上,那么就是根据a列内容的前100长度的内容去建立索引
						例：
							a列有4个值 abc,efghijkl,aa.
							a列上建立长度3的索引,那么参与建立索引的数据 abc,efg,ijk,aa
					索引长度小，有利于减小索引项空间，然后有利于减小b+树高度，最后减小搜索时io提高搜索效率。
						例：
							建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高  INSERT的更新速度。
						附：
							mysql中索引长度与区分度的选择：
								https://blog.csdn.net/heyuqing32/article/details/80966301
			例：
				CREATE UNIQUE INDEX sIndex ON Student(sname,lastName)
				附：
					？非聚集索引，聚集索引
					使用ALTER 命令添加：
						ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
						ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
						ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。
						ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。
		单列索引:
			即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
		组合索引:
			https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html
			一个索引包含多个列。
			例：
				https://www.jianshu.com/p/40edfbb50046
				3个字段：name, city, age、
				如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，远低于组合索引。
				因为此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。
					！就是说mysql查询时只会使用一个(mysql任务效率最好的)索引吗
					应该是的
					select * FROM UMS_LOGIN_LOG WHERE UNIT_NAME LIKE '%吕' and USER_NO = '1300B00081217843';
					像这里就后一个索引
				建立组合索引
					ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);
			区别：
				https://blog.csdn.net/Abysscarry/article/details/80792876
				同时存在联合索引和单列索引（字段有重复的），这个时候查询mysql会怎么用索引呢。
					这个涉及到mysql本身的查询优化器策略了，当一个表有多条索引可走时, Mysql 根据查询语句的成本来选择走哪条索引；
				什么时候要用组合索引了：
					看是否会应用到多字段查询或排序
					索引越少更新成本越低
				最左前缀原则：
					./mysql索引原理.txt goto: 索引的最左匹配特性
					
	删除索引：
		语法：
			Mysql: DROP INDEX <索引名> on <表名>
			SqlServer: drop index <表名>.<索引名>
	注：
		查看表上拥有的索引：
			show index from <表名>;		


