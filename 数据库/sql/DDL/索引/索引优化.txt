索引建设原则：(索引创建建议)
	1．为搜索条件、联合等操作的字段建立索引.
		1. 搜索条件: 
			为常作为查询条件的字段建立索引.
			./搜索条件如何应用索引.txt
		2. 联合：
			1. 对于两表连接的字段，可以建立索引。
			具体goto：
				数据库/DML/sql详细/表连接/README.txt
			2. 对于in,exist，NOT exits，NOT IN的字段，可以建立索引。
			具体goto：
				数据库/sql/优化/效率/SQL中in、exist效率.txt
			附：
				mysql任何关联原理都是嵌套循环查询+where条件筛选

		3. 分组：
			1. 对于分组字段，也可考虑建立索引。
			具体goto：
				数据库\sql\DML\sql详细\分组group by\group by.txt
		4. 排序：
			如果经常在某表的一个字段进行Order By 则也可考虑创建最左前缀的索引。
			具体goto：
				数据库\sql\优化\效率\排序与索引\
			附：
				如果想优化排序还是以explain实战为准
		
		附：
			任何语句的优化建议以explain实战为准
	4. 适量数目的索引：
		设置适量数目的索引，不要造成过多的索引。
		
		原因：	
			因为每个索引需要额外的磁盘空间。
			降低写更操作的性能。
				在修改表内容的时候，索引会进行更新，更有甚至需要重构，索引列越多，所花费的时间就会越长。所以只保持需要的索引有利于查询即可。
		优化：
			可考虑联合索引替换掉部分单列索引。
			例：
				新增索引时可尽量考虑扩展索引，不新建索引。
			
		？
			怎么考虑是否适量了

		？一定联合索引更优吗
				那组合索引是会导致树更高吗，所以不一定组合索引就好吗？
	2.尽量使用短索引
		对字段创建索引时，如果可能应该指定一个前缀长度。
		如此可以减小索引树高度就可减少io次数，加快了查找速度对新增更新也有利处。
		例：
			如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。
			
			短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
		原因：
			通过 ./mysql索引原理.txt 的分析，我们知道IO次数取决于b+数的高度h。
			假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，？当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。
	
	3．离散型越高越好：
		尽量选择区分度高的列作为索引。
		因为离散度越高，通过索引最终确定的范围越小，最终扫面的行数也就越少(即io次数越少)。
		附：
			区分度的公式：
					count(distinct col)/count(*)，
					表示字段不重复的比例，比例越大我们扫描的记录数越少，
					唯一键的区分度是1，
					而一些状态、性别字段可能在大数据面前区分度就是0，
						?
							性别字段也有意义吧？？？它也能省1半的查找量吧
							如果性别字段对应的指针块数量特别大，它是怎么存储的的？
					？
						我很想知道比如0，1两种索引，应该是只对存储了2个指针位吧，那叶节点是如何存那么多行数据的？。那先找到第一个指针位数据块，这个数据块后面又跟了下一个指针位数据块吗？
					？
						那可能有人会问，这个比例有什么经验值吗，使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。
			mysql中索引长度与区分度的选择：？
				https://blog.csdn.net/heyuqing32/article/details/80966301
	
	
	附：
	5. 自增主键作用：
		...
		https://blog.csdn.net/weixin_36070797/article/details/113911317
优化技巧：
	聚簇索引推导出的优化技巧：
		2. 主键不应该过大，因为主键太大，其他索引也都会很大。
				是指其他索引的叶节点会过大吧！
		1. 通过主键索引效率很高。
			在根据主索引搜索时，直接找到对应的叶节点数据即可；
	慎用NOT IN、exits、NOT exits：
		这3个应该都是嵌套(索引)循环查询，即把外面的所有数据拿去里面走循环。
		所以这3个仅适用与外小内大。
		5.7后in则没有这种限制，应该是mysql优化了。
		具体goto：
			/数据库\sql\优化\效率\SQL中in、exist效率.txt
		???
			应用的是那个索引

