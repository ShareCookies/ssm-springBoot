https://tech.meituan.com/2014/06/30/mysql-index.html

预读：（磁盘IO与预读）
	磁盘读写，并不是按需读取，而是按页读取。
		附：
			一页大小：
				具体一页有多大数据跟操作系统有关，一般为4k或8k。
			为什么操作系统一次至少读一页数据：
				每一次IO读取的数据我们称之为一页(page)。
				操作系统考虑到磁盘IO是非常高昂的操作，因此做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。
				附：
					为什么要读取相邻数据：(局部预读性原理)
						因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据科恩大概率也会很快被使用到。
	也就是说我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。
	附：
		为什么很有帮助了：
			通过少量的io次数就找到数据就是索引的真正目的。
			那么因为利用io预读特性，我们使用b树数据结构实现仅需操作少量的节点(io页)，就可找到所需数据所在叶节点。
			如何操作少量节点：
				节点仅存储数据范围，我们通过1级范围找到下级更精确的范围，最后找到数据所在页。
BTREE索引原理：
	b+树如何存放数据：
		指针磁盘块（节点）：
			浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示）。
			例：
				磁盘块1包含数据项17和35，包含指针P1(P1表示小于17的磁盘块)、P2(P2表示在17和35之间的磁盘块)、P3(P3表示大于35的磁盘块)。
		数据磁盘块（叶节点）：
			真实的数据存在于叶子节点。
				即3、5、9、10、13、15、28、29、36、60、75、79、90、99。
			非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项。
				如17、35并不真实存在于数据表中。
		例图：
			b+树如何存放数据.jpg
	b+树如何查找数据：
		例：
		主键BTREE索引
			1.如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针。
				附：
					内存时间因为非常短（相比磁盘的IO）可以忽略不计
			2.通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针。
			3.通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。
			注：
				真实的情况下，3层的b+树可以表示上百万的数据？，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

	b+树目的：查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。


b+树性质导致的索引特性：


	建索引的几大原则
		1.最左前缀匹配原则

		2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

		3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

		4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

		5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
		那组合索引是会导致树更高吗，所以不一定组合索引就好吗？