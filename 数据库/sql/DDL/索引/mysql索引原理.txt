https://tech.meituan.com/2014/06/30/mysql-index.html

磁盘IO与预读：
	预读：
		考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。
		每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。


b+树：
	b+树目的：查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。

	附：
		b+树如何存放数据：
			指针磁盘块（节点）：
				浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示）。
				如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。
			数据磁盘块（叶节点）：
				真实的数据存在于叶子节点。
					即3、5、9、10、13、15、28、29、36、60、75、79、90、99。
				非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项。
					如17、35并不真实存在于数据表中。
		b+树如何查找数据：
			
			如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针。
			内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针。
			通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。
			真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

		b+树性质导致的索引特性：
			1.索引字段要尽量的小
				通过上面的分析，我们知道IO次数取决于b+数的高度h。
				假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，！当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

			2.索引的最左匹配特性
				介绍：
					最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。
					（关键字：最左边的为起点，连续的索引，范围查询）
						如果建立(a,b,c,d)的索引则都可以用到，a,b,c,d的顺序可以任意调整，因为优化器会自动调整顺序。。
					
				原理：
					原理图：
						https://www.cnblogs.com/lanqi/p/10282279.html
						索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。
						例：
							创建一个（a,b)的联合索引，那么它的索引树是这样的:
							./联合索引B树.png
							以a为核心构成了一个b树。
								可以看到 a的值是有顺序的 1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。
								所以b = 2这种查询条件没有办法利用索引。
							a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。
								所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。
								所以：
									a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的。
									而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。
										此处a找完后，b因为无序所以只能遍历，b其实就没用上索引，所以为什么叫遇上范围查询就会停止。
							！
								如果是a，b，c。那我 a = 1 and c = 2 也能用上索引吧，因为我觉的a有序下，c也有序。
								答案要研究下a，b，c的索引构成。或实操看下。
								
								答：错
									https://blog.csdn.net/sinat_41917109/article/details/88944290
									select * from table_name where a = '1' and c = '3' 
									如果不连续时，只用到了a列的索引，b列和c列都没有用到 
					当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，
						比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；
						但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。
						比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。
					!:
						a,b,c联合索引，a，b
			建索引的几大原则
				1.最左前缀匹配原则

				2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

				3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

				4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

				5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
				那组合索引是会导致树更高吗，所以不一定组合索引就好吗？