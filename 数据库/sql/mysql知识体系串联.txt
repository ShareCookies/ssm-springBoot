mysql知识体系串联：
	数据库是一个提供数据存储和查询的一个应用。
	和数据库建立连接后，我们就可以通过sql来操作它，SQL可分为两个部分：  DDL (Data Definition Language数据定义语言)和DML ( DataManipulateLanguage数据操作语言) 。
	
	1. 首先要通过ddl建表。ddl又可分为：建表sql、建索引sql。
        索引是什么：
            索引相当于字典目录作用。
                附：查字典时可以根据字典目录可以快速找到单词，
            数据库可以根据索引可以快速找到对应数据。
        索引原理：
            索引的数据结构：
                数据是存在磁盘上的，由于磁盘的读取特性 数据是按页从磁盘读取到内存。
                因以上特性innodb存储引擎的索引默认使用的是b+树 数据结构 来存储数据，b+树的节点为索引值 其叶节点存储了数据？
                    附：还有hash索引数据结构
                    附：
                        不同存储引擎其叶节点存储数据的又不同，
                        innodb存储引擎聚簇索引、myisam非聚簇
            索引值的构造可以通过单列、也可以多列。
                注：
                    索引不是只有一颗的哦，查询优化器分析后
                    1.有可能应用1棵索引树+主键索引树就完成查询。
                    2.也可能 多颗索引树查询结果合并拿去主键索引树进行查询。
            据此我们就可以推导出索引的创建原则和使用原则：
                创建：
                    为哪些字段创建索引：
                        搜索条件、关联、排序、分组
                        字段最好符合：
                            离散够高 字段不用太长
                    附：主键
                        非分布式可考虑 自增主键
                应用：
                    and or、like
                    最左原则：最左开始、遇上范围查询结束
	2. 建完表后就可以通过dml进行数据插入。
	dml包括：就是常见的curd
	事务：
		数据库(dml)操作的最小执行单元，
		一个事务：开启-各种dml操作-事务提交或回滚
			附：为什么可以直接操作一个dmlsql，因为一个mysql默认为一个sql的提交开启了事务
		事务具有a(原子)c(一致)i(隔离)d(持久)特性，
			原子性是通过undo来实现的，
			持久性是通过redo来实现的，
			一致性是各种数据库约束，
			隔离性的实现就复杂了，
			
				事务并发会产生脏读、幻读、不可重复读、修改丢失(回滚丢失、覆盖丢失)
				用户可以通过控制隔离级别来避免不同问题
					读未提交、读已提交、可重复读、序列化
					
				正常下可重复读可避免脏读和不可重复读
				但mysql的rr却可避免all、除了覆盖丢失
					mysql的rr能这么强是因为mvvc和临键锁
					覆盖丢失可通过加个冗余字段where比较来避免问题
		锁：
			事务并发时 sql间如果操同一数据就可能会出现问题，锁就是用来解决事务并发时 数据写操作安全的问题。
			按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。
				innodb对于行的查询默认使用next-key lock(记录锁和间隙锁的结合)。
				当查询的索引含有唯一属性时，将next-key lock降级为record key

			按照锁类型划分，锁可以分为无锁、共享锁（s）和排他锁（X），意向锁。
				共享锁:可获取共享锁禁止获取排他锁
				排他锁:禁止获取任何锁
				意向锁：
					意向锁是InnoDB特殊的表级锁，意向锁分为意向共享锁(IS)和意向排他锁(IX)两种。在添加行锁之前，innode会自动为表添加意向锁。
					意向锁作用是提高表锁添加的效率，有了意向锁，添加表锁时只需要判断该意向锁与即将添加的表级锁是否兼容即可，而不用去遍历是否有行锁的存在。


	mysql查询过程：
		？
		
		应用层、服务层、存储引擎
	
	优化：
		索引、缓存、垂直分表、分片、分库