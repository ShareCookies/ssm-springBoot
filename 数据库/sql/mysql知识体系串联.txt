mysql知识体系串联：
	数据库是一个提供数据存储和查询的一个应用。
	和数据库建立连接后，我们就可以通过sql来操作它，SQL可分为两个部分：  DDL (Data Definition Language数据定义语言)和DML ( DataManipulateLanguage数据操作语言) 。
	
	1. 首先要通过ddl建表。ddl又可分为：建表sql、建索引sql。
        索引是什么：
            索引相当于字典目录作用。
                附：查字典时可以根据字典目录可以快速找到单词，
            数据库可以根据索引可以快速找到对应数据。
        索引原理：
            索引的数据结构：
                数据是存在磁盘上的，由于磁盘的读取特性 数据是按页从磁盘读取到内存。
                因以上特性innodb存储引擎的索引默认使用的是b+树 数据结构 来存储数据。
            innodb索引数据架构：
                聚簇索引：主键b+树的节点为索引值 其叶节点存储了数据。
                非聚簇索引：非主键索引节点为索引值 其叶节点存储了主键。(所以这就是为啥叫非聚簇索引，因为它要进行回表才能查到数据)！
                    附：还有hash索引数据结构

            索引值的构造可以通过单列、也可以多列。

        据此我们就可以推导出索引的创建原则和使用原则：
            创建：
                为哪些字段创建索引：
                    搜索条件、关联、排序、分组
                    字段最好符合：
                        离散够高 字段不用太长
                附：主键
                    非分布式可考虑 自增主键
            如何写sql才能应用索引：考虑以下情况
                and or、like、最左原则：最左开始、遇上范围查询结束
                附：
                    一次查询中索引不是一定只用一颗的，查询优化器分析后。
                    1.有可能应用1棵索引树+主键索引树就完成查询。2.也可能 多颗索引树查询结果合并拿去主键索引树进行查询。
                附：
                    实践中通过explain来诊断优化sql
	2. 建完表后就可以通过dml进行数据插入。dml包括：就是常见的curd
	事务：
		数据库dml操作的最小执行单元。
		一个事务生命周期：事务开启-各种dml操作-事务提交或回滚
			附：平常为啥可以直接执行一个dmlsql，因为自动事物 即mysql默认为一个sql的提交开启了事务
		事务具有a(原子)c(一致)i(隔离)d(持久)特性，
			原子性是通过undo log来实现的，
			持久性是通过redo log来实现的，
			一致性是各种数据库约束，
			隔离性：
				事务并发导致的问题：会产生 脏读、幻读、不可重复读、修改丢失(回滚丢失、覆盖丢失)。
				数据库则通过提供不同的事物隔离级别来分别避免不同的以上问题。
					读未提交、读已提交(避免脏读)、可重复读(避免脏读、不可重复读)、序列化(避免all)
					附：
					    数据库通常默认可重复读级别，用户可以通过控制隔离级别来避免不同问题
				但mysql的rr却可避免所有事物并发问题(除了覆盖丢失).
					mysql的rr能这么强是因为mvvc和临键锁
					附：
					    覆盖丢失可通过加个冗余字段当版本号，where比较来避免问题
					附：
					    MVCC：
					        在同一时刻，不同的事务读取到的数据可能是不同的（即多版本数据）。
					        MVCC实现：
                                InnoDB的mvcc 实现 多个版本的数据可以共存，主要是依靠数据的隐藏列（也可以称之为标记位）和undo log来实现的。
                                    数据的隐藏列包括了：该行数据的版本号、删除时间、指向undo log的指针等等；
                                当读取数据时，MySQL 可以通过 隐藏列-版本号 判断是否是当前事物所需版本数据，如果不是则需要回滚(找到回滚需要的undo log)；
					    幻读避免：
					        加锁读：next-key lock 相当于record lock(记录锁) + gap lock(间隙锁)
					        不加锁读：mvcc对读取的数据做了标记,所以读取到的数据不会有改变。
					    不可重复读避免:
					        当会话1在再一次读取数据时，发现数据的版本号2大于第一次读取时记录的版本号1，因此会根据undo log执行回滚操作，得到版本号为1时的数据，从而实现了可重复读。
                        回滚丢失避免:
                            mvcc发现版本对不上就不回滚
                        附：
                            MVCC 最大的优点是读不加锁，因此读写不冲突，并发性能好。
		锁：
			事务并发时 sql间如果操同一数据就可能会出现问题，锁就是用来解决事务并发时 数据写操作安全的问题。
			默认 更新操作都会给对应的数据加锁，读取操作不会加锁 （当然读取也可手动加锁）。

            锁的分类：
                按照粒度，锁可以分为表锁、行锁、间隙锁(以及其他位于二者之间的锁)。
                    innodb对于行的查询默认使用next-key lock(记录锁和间隙锁的结合)。
                    附：当查询的索引含有唯一属性时，将next-key lock降级为record key

                按照锁类型划分，锁可以分为 无锁、共享锁（s）和排他锁（X），意向锁。
                    无锁：默认读取操作不会加锁
                    共享锁:可获取再次获取共享锁 禁止获取排他锁
                    排他锁:禁止再次获取任何锁
                    意向锁：提高表锁的获取效率，innodb自动添加



	mysql查询过程：
	    https://bbs.huaweicloud.com/blogs/314468?utm_source=zhihu&utm_medium=bbs-ex&utm_campaign=ei&utm_content=content
        建立连接。
            首先我们会连接到这个数据库上
        发送请求：
            客户端向MySQL服务器发送一条查询请求的执行过程：
        服务器查询请求执行过程：
            服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段(msql8已移除)
            服务器进行SQL解析、预处理、再由优化器生成生成真正的执行计划。
            MySQL根据执行计划，调用存储引擎的API来执行查询
            将结果返回给客户端，同时缓存查询结果

        附：
            客户端到服务端之间的原理
                客户端和服务端之间是半双工的， 即一个通道内只能一个在发一个接收， 不能同时互相发互相接收
                客户端只会发送一个数据包给服务端，并不会在应用层拆成2个数据包去发（max_allowed_packet可以设置数据包最大长）， 这关系到sql语句不能太长。
                ？服务端返回给客户端可以有多个数据包， 但是客户端必须完整接收，不能接到一半停掉连接或用连接去做其他事（UI界面可以操作，不同的线程）
                ？例如java，如果没设置fetchSize，那么都是一次性把结果读进内存。当你使用resultSet的时候，其实已经全部进来了，而不是一条条从服务端获取。————使用fetch Size边读边处理的坏处： 服务端占用的资源时间变久了。
        附：./MySQL查询过程.jpg
附：
	优化：sql语句调优、索引调整，垂直分表、分片、分库。附：缓存 主从等
