临时表：
	介绍：将查询结果作为另一个查询语句的来源
	例：
		select * from(select * from test)  a

表连接:
	位置：
		from 后 ，where 前。
		注：表连接要与on配合，on设置连接条件
	介绍：
		表连接分内连接和外连接。
			内连接：是保证两个表中所有的行都要满足连接条件。
			外连接：某些不满条件的列也会显示出来。即只限制其中一个表的行，而不限制另一个表的行。
				分左连接、右连接、全连接三种。
	inner join：
		介绍：简写join。内连接，返回左右表均有的值。
		样例：
			写法1：select * from client as c inner join financial_account as f on c.idcard = f.idcard 
			写法2：select * from client  c join financial_account  f on c.idcard = f.idcard 
		注：
			内连接可以不加on，此时效果与笛卡尔积连接一样。！
	left outer join：
		介绍：简写left join。左连接，左表数据全部显示，且左表有的右表没有的则显示为null。
		样例：
	right outer join：
		介绍：
			简写right join。右连接，右表数据全部显示，且右表有的左表没有的则显示为null。
			即显示左表所有内容，右边没有与之对应的内容则显示为null。
		样例：
	full out join：
		介绍：
			MySQL中不支持 FULL OUTER JOIN。
			简写full join 。全连接，返回两表所有数据未匹配项用null代替。
			即：左连接结果与右连接结果的合并。
		mysql模拟实现全连接：
			SELECT * FROM t1
			LEFT JOIN t2 ON t1.id = t2.id
			UNION
			SELECT * FROM t1
			RIGHT JOIN t2 ON t1.id = t2.id
	其余连接：
		逗号连接（笛卡尔积连接）：
				介绍：
					cross join 简写 ,
					笛卡尔积连接就是第一个表的行数乘以第二个表的行数。
				例：
					select * from client  c , financial_account as f 
					这样是以广义笛卡尔积查询出数据，若用where规定连接条件就等同内连接
				注：
					1.
						用cross join时可使用on查询
						逗号时不行
				自连接:
					样例:
						select a.id,b.id,b.pid,b.name 
						from test as a,test as b 
						where a.id=b.pid
				三表连接：
					写法1：select * from student inner join teacher on student.id=teacher.sid inner join project on student.id=project.sid;  
					写法2：select * from student,teacher,project where student.id=teacher.sid and student.id=project.sid;
				，与inner join关系：
					https://blog.csdn.net/huanghanqian/article/details/52847835

		非等连接：？
			介绍：使用等值以外的条件来匹配左、右两个表中的行 select A.c1,B.c2 from A join B on A.c3 != B.c3;
	注：
		关联条件on尽量有所有
		关联时尽量有where且有索引
mysql如何执行关联查询：高性能mysql p214
	当前MySQL*(5.0)关联执行的策略很简单:MySQL对任何关联都执行嵌套循环关联操作，
	即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。
	例：
		SELECT tbl1.col1, tbl2.col2
		FROM tbl1 INNER J0IN tbl2 USING( col3)
		WHERE tbl1.col1 IN(5,6);
		1.
			假设MySQL按照查询中的表顺序进行关联操作，我们则可以用下面的伪代码表示
			MySQL将如何完成这个查询:
				outer_iter = iterator over tbl1 where col1 IN(5,6)
				outer_row = outer_iter.next
				while outer_row
					inner_iter = iterator over tbl2 where col3 = outer_row.co13
					inner_row = inner_iter.next
					while inner_row
						output [outer_row.col1, inner_row.col2]
						inner_row = inner_iter.next
					end
					outer_row = outer_iter.next
				end
		2. 通过泳道图展示MySQL如何完成关联查询:
			./关联查询泳道图.png
		附：
			从字面来看会先遍历tab1，把tab1拿去循环tab2
			所以where中查询的是tbl1的时候才能优化tab1查询。
			但从测试中(mysql5.7)看where中只有tab2也行。？
		？
			先对1表进行where
			1表结果在拿去跟2表嵌套循环
			在2表where？
	附：
		MySQL认为任何一个查询都是一次“关联”--并不仅仅是一个查 询需要到两个表匹配才叫关联，所以在MySQL中，每一个查询，每一个片段(包括子查询，甚至基于单表的SELECT)都可能是关联。

连接算法：
	https://www.cnblogs.com/shangyu/p/6055181.html
	hash join是一种数据库在进行多表连接时的处理算法，对于多表连接还有两种比较常用的方式：sort merge-join 和 nested loop。 
	对于不同的查询方式，使用相同的join算法也会有不同的代价产生，对于具体使用哪一种连接方式是由优化器通过代价的衡量来决定的。
	nested loop join
		嵌套循环连接，是比较通用的连接方式，分为内外表，每扫描外表的一行数据都要在内表中查找与之相匹配的行。
			(即对嵌套的内表进行不断循环)
		没有索引的复杂度是O(N*M)，这样的复杂度对于大数据集是非常劣势的，一般来讲会通过索引来提升性能。
			？是指对内表索引来提高性能吗
 　 sort merge-join
		merge join需要首先对两个表按照关联的字段进行排序，分别从两个表中取出一行数据进行匹配，如果合适放入结果集；
		不匹配将较小的那行丢掉继续匹配另一个表的下一行，依次处理直到将两表的数据取完。
		merge join的很大一部分开销花在排序上，也是同等条件下差于hash join的一个主要原因。
	hashjoin：
		https://www.cnblogs.com/shangyu/p/6055181.html
		原理：
			对于简单的两个表来讲，hash-join就算将两表中的小表（称S）作为hash表，然后去扫描另一个表(称M)的每一行数据，用得出来的行数据根据连接条件去映射建立的hash表，hash表是放在内存中的，这样可以很快的得到对应的S表与M表相匹配的行。
			hash-join只适用于等值连接，对于>, <, <=, >=这样的查询连接还是需要nested loop这种通用的连接算法来处理。
			如果连接key本来就是有序的或者需要排序，那么可能用merge-join的代价会比hash-join更小，此时merge-join会更有优势。
				附：
					对于结果集很大的情况，merge-join需要对其排序效率并不会很高，
					而nested loop join是一种嵌套循环的查询方式无疑更不适合大数据集的连接，
					而hash-join正是为处理这种棘手的查询方式而生，尤其是对于一个大表和一个小表的情况，基本上只需要将大小表扫描一遍就可以得出最终的结果集。
		附：
			mysql5.7不支持hashjoin，mysql8支持了hashjoin。
				https://dev.mysql.com/doc/refman/5.7/en/
				https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html
			hashjoin其实还有很多需要考虑和实现的地方，比如数据倾斜严重如何处理、内存放不下怎木办，hash如何处理冲突等，这些并不是本文介绍的重点，不再详述，每个拿出来都可以再讲一篇了。