EGOV_RECEIVAL：112887 索引：id主建、FLOW_PID索引
FLOW_PROCESS_INSTANCE：122665 索引： id主建

SELECT * FROM EGOV_RECEIVAL r INNER JOIN FLOW_PROCESS_INSTANCE p ON r.FLOW_PID = p.ID 
//3s 查出96000条

1	SIMPLE	r		ALL	testForJoin				107536	100.00	Using where
1	SIMPLE	p		eq_ref	PRIMARY	PRIMARY	48	zjgy_real.r.FLOW_PID	1	100.00	Using where



为什么第二个扫描行数为1：
	是因为嵌套循环查询原因吧，p表虽然1行，但被查询了107536次。



SELECT * FROM EGOV_RECEIVAL r INNER JOIN FLOW_PROCESS_INSTANCE p ON r.FLOW_PID = p.ID where p.ID = 'W-4lI-SwQwQ9PF0U';
//0.034s 查出一条记录

1	SIMPLE	p		const	PRIMARY	PRIMARY	48	const	1	100.00	
1	SIMPLE	r		ref	testForJoin	testForJoin	51	const	1	100.00	


SELECT * FROM EGOV_RECEIVAL r INNER JOIN FLOW_PROCESS_INSTANCE p ON r.FLOW_PID = p.ID where p.DRAFT_USER_NO = '1300B00081217030';
//0.4 查出4498条数据

1	SIMPLE	p		ALL	PRIMARY				119184	10.00	Using where
1	SIMPLE	r		ref	testForJoin	testForJoin	51	zjgy_real.p.ID	1	100.00	Using index condition


附：
	where没有索引查询也比只查询快很多，很大可能时因为数据量大，大部分耗时在传输的过程了。