锁机制：
	https://blog.csdn.net/weixin_41050155/article/details/88088419
	*https://www.cnblogs.com/sessionbest/articles/8689071.html
	https://blog.csdn.net/qq_34337272/article/details/80611486
	

	介绍：
		Mysql使用了锁机制，解决事务并发，数据写操作安全的问题。
		表级锁和行级锁：
			介绍：
				按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。
                表锁在操作数据时会锁定整张表，并发性能较差；
                行锁则只锁定需要操作的数据，并发性能好。
	                附：
	                    MySQL存在多种数据存储引擎，每种存储引擎支持的锁又不一样。
	                        InnoDB存储引擎支持行级锁(row-level locking)和表级锁,默认为行级锁.
	                        MyISAM存储引擎只支持表级锁(table-level locking)。
	                    符：
	                        MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。

			表级锁：
				MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁。
					缺点：其锁定粒度最大，触发锁冲突的概率最高，并发度最低。
					优点：实现简单，资源消耗也比较少，加锁快，不会出现死锁。
				附：
					如何加表锁:
						https://www.cnblogs.com/sessionbest/articles/8689071.html
						MyISAM:
							MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁。
							在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
							这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。
						innodb：
							innodb手动加表锁？
					什么时候用表级锁：
						1. 事务更新大表中的大部分数据直接使用表级锁效率更高；
						附：加锁本身需要消耗资源（获得锁、检查锁、释放锁等都需要消耗资源），因此在锁定数据较多情况下使用表锁可以节省大量资源。
						2. 事务比较复杂，使用行级索很可能引起死锁导致回滚。
			行级锁：
				介绍：
					MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。
						缺点：加锁的开销也最大，加锁慢，会出现死锁。
						优点：其加锁粒度最小，并发度高。行级锁能大大减少数据库操作的冲突。
				InnoDB行级锁的实现算法有三种：（InnoDB支持的3种类型的行级锁）
					Record Lock: 记录锁
						对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；
					Gap Lock: 间隙锁
						间隙锁，对索引项之间的'间隙'加锁，锁定记录的范围，不包括记录本身。

						其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
						附：
							无对应记录，则会加间隙锁
								SELECT * FROM `eas`.`WRONG_IMG` WHERE ID = '66' LOCK IN SHARE MODE
								无66id，此时加了间隙锁，此时是不允许新增id为66的记录了。
					Next-key Lock：临键锁
						Record Lock和Gap Lock的结合，锁定索引项本身和索引范围（ 锁定一个范围，包含记录本身）。
						解决了幻读问题。
						附：
							innodb对于行的查询默认使用next-key lock。
							当查询的索引含有唯一属性时，将next-key lock降级为record key
					注：
						# InnoDB的行级锁特性:
							*1. InnoDB的行级锁是基于索引实现的.
								即InnoDB的行级锁是通过给索引上的索引项加锁来实现的
								附：
									因为InnoDB的行级锁是针对索引加的锁，不针对数据记录。
									因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突。
							*2.如果查询语句未命中任何索引，那么InnoDB会使用表级锁.
								即只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁.
								附：
									通过explain结果的type值结果是否为all等，可以来判断是否为所有的记录加锁了。
								例：
									begin;
	                                SELECT * FROM `eas`.`WRONG_IMG` WHERE CLASSIFY_ID = '%9ea0%' LOCK IN SHARE MODE #无索引，给所有的记录加了行级锁
	                                SELECT * FROM `eas`.`WRONG_IMG` WHERE ID = 'befaefa97ad143ed8f206fed8f7df0fa' LOCK IN SHARE MODE  #主建索引，给所有的记录加了行级锁
	                                COMMIT;
							附：
								1.在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。
								2.即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。
								因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。
					附：			
						死锁：
							不同于MyISAM总是一次性获得所需的全部锁，InnoDB的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。 
							发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。
							但我们最好尽量避免死锁的产生：
								我们可以采取以下方式避免死锁。
								3.同一个事务尽可能做到一次锁定所需要的所有资源。？
									尽可能方法开始时一次性获取所有的资源。
									而不是获取资源-处理-在获取-在处理，因为这样子死锁概率就可能上升了。
									附：
										一个事务设计到多个查询语句，那么这里锁的释放是一个语句结束了就放了还是等到事务完结才释放：
											1.默认读是不加锁的
											2.如果有锁，那么是要等到事务完成才释放。
								1.通过表级锁来减少死锁产生的概率；
									对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

								2.多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；？

						InnoDB行锁优化建议：
							a)尽可能让所有的数据检索都通过索引来完成。
							从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定；
							b)合理设计索引。
							让InnoDB在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；
							c)尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；
							d)尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
							e)在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本。
						InnoDB 的行级锁定状态变量：!
							InnoDB_row_lock_current_waits：当前正在等待锁定的数量；
							InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；
							InnoDB_row_lock_time_avg：每次等待所花平均时间；
							InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；
							InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；
							附：
								当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。
								如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。
							例：
								show  status  like "Innodb_row_lock%";
			附：
			页级锁定（page-level）：
				MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。
				表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。
				开销加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。
				使用页级锁定的主要是BerkeleyDB存储引擎。

		共享锁和排他锁：
			表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X），意向锁。

			ShareLocks共享锁：(s)
				又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。
					若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
				
			ExclusiveLock排他锁：(x)
				1.又称为写锁，它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。
					若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。
			意向锁：
				意向共享锁(IS)和意向排他锁(IX)两种：
					...
				注：
					1. IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突
					2. 意向锁是InnoDB自动加的，不需用户干预。在添加行锁之前，innode会自动添加意向锁！
				
				意向锁作用：
					https://www.zhihu.com/question/51513268/answer/147733422

					当再向一个表添加表级X锁的时候：
						如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。
						因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果
			附：
				如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。

			注：
				？
					mysql的sql语句默认是无锁的吧，包括事务中的sql语句吧。
					所以sql语句想要有锁，都要手动加吧。
					但是spring事务提交的又好像是有锁的哦
					有空实测下：navicate事务提交、spring事务提交
					是否是下面的，有空在回顾下
				锁是自动加的：
					对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
					对于普通SELECT语句，InnoDB不会加任何锁：
						例：
							1.执行
								BEGIN;
								SELECT * FROM test for UPDATE;
							2.再开启一个控制台执行更新语句，或直接navicat进行更新，会发现未返回结果
							3. 再1界面执行commit后，发现2返回了，可见1加排他锁成功。
							4. 1改造下
							执行
								BEGIN;
								SELECT * FROM test;
							在执行2，发现2返回了，可见对于普通SELECT语句，InnoDB不会加任何锁。
				手动加锁：
					事务可以通过以下语句显示给记录集加共享锁或排他锁：

					共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
						1.用SELECT ... IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。
						2.但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁。
					排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE
				查看引擎：
					show ENGINES;
				 InnoDB行锁模式兼容性列表：
					....
					https://www.cnblogs.com/Arlen/articles/1756616.html
mysql为啥会锁死表？
	https://blog.csdn.net/yangfengjueqi/article/details/81062123
	https://www.cnblogs.com/ShaunChen/p/7492056.html
		？卡死就是指对表无法新增和删除，但还可以新增吧
		MySQL如果频繁的修改一个表的数据，那么这么表会被锁死。造成假死现象。
		？
			为什么了
		？
			我有次没什么操作也锁死了表，为什么了
		
	释放锁：
		./释放锁.txt
		
		
附	https://blog.csdn.net/weixin_41050155/article/details/88088419
	https://blog.csdn.net/caohao0591/article/details/79887028