锁机制：
	https://blog.csdn.net/weixin_41050155/article/details/88088419
	*https://www.cnblogs.com/sessionbest/articles/8689071.html
	https://blog.csdn.net/qq_34337272/article/details/80611486
	

	介绍：
		Mysql为了解决并发数据安全的问题，使用了锁机制。
		MySQL存在多种数据存储引擎，每种存储引擎支持的锁又不一样。
			InnoDB存储引擎支持行级锁(row-level locking)和表级锁,默认为行级锁.
			MyISAM存储引擎采用表级锁(table-level locking)。
			符：
				MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。
		可以按照锁的粒度把数据库锁分为表级锁和行级锁。
		
		表级锁和行级锁：
			表级锁：
				MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁。
					缺点：其锁定粒度最大，触发锁冲突的概率最高，并发度最低。
					优点：实现简单，资源消耗也比较少，加锁快，不会出现死锁。
				附：
					如何加表锁:
						MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁。
						在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
						这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。
					表级锁定的状态变量：
						这里有两个状态变量记录MySQL内部表级锁定的情况：
							Table_locks_immediate：产生表级锁定的次数；
							Table_locks_waited：出现表级锁定争用而发生等待的次数；
								如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了。
							两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。
					...表锁优化:
						https://www.cnblogs.com/sessionbest/articles/8689071.html
							...
							
			行级锁： 
				介绍：
					MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。
						缺点：加锁的开销也最大，加锁慢，会出现死锁。
						优点：其加锁粒度最小，并发度高。行级锁能大大减少数据库操作的冲突。
				InnoDB行级锁的实现算法有三种：（InnoDB支持的3种类型的行级锁）
					Record Lock: 记录锁
						对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；
					Gap Lock: 间隙锁	
						间隙锁，对索引项之间的'间隙'加锁，锁定记录的范围，不包括记录本身。
						
						其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
					Next-key Lock：
						Record Lock和Gap Lock的结合，锁定索引项本身和索引范围（ 锁定一个范围，包含记录本身）。
						解决了幻读问题。
						注：
							innodb对于行的查询默认使用next-key lock。
							当查询的索引含有唯一属性时，将next-key lock降级为record key
					注：
						# InnoDB的行级锁特性:
							1. InnoDB的行级锁是基于索引实现的.
								即InnoDB的行级锁是通过给索引上的索引项加锁来实现的
								附：
									因为InnoDB的行级锁是针对索引加的锁，不针对数据记录。
									因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突。
							2.如果查询语句未命中任何索引，那么InnoDB会使用表级锁.
								即只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁.
								通过explain结果的type值可以证明。
							附：
								1.在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。
								2.即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。
					附：			
						死锁：
							不同于MyISAM总是一次性获得所需的全部锁，InnoDB的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。 
							发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。
							但我们最好尽量避免死锁的产生：
								我们可以采取以下方式避免死锁。

								1.通过表级锁来减少死锁产生的概率；
									对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

								2.多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；？
								3.同一个事务尽可能做到一次锁定所需要的所有资源。？
									一个事务设计到多个查询语句，那么这里锁的释放是一个语句结束了就放了还是等到事务完结才释放。？
									如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。

						InnoDB行锁优化建议：
							a)尽可能让所有的数据检索都通过索引来完成。
							从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定；
							b)合理设计索引。
							让InnoDB在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；
							c)尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；
							d)尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
							e)在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本。
						InnoDB 的行级锁定状态变量：
							InnoDB_row_lock_current_waits：当前正在等待锁定的数量；
							InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；
							InnoDB_row_lock_time_avg：每次等待所花平均时间；
							InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；
							InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；
							附：
								当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。
								如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。
						
			页级锁定（page-level）：
				MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。
				表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。
				开销加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。
				使用页级锁定的主要是BerkeleyDB存储引擎。
			附：
				什么时候用表级锁：
					事务更新大表中的大部分数据直接使用表级锁效率更高；
					事务比较复杂，使用行级索很可能引起死锁导致回滚。
					适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。
		对锁进行分类：
			表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X）。

			ShareLocks共享锁：
				又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。
					若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
				
			ExclusiveLock排他锁：
				1.又称为写锁，它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。
					若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。
			意向锁：
				1.在锁定机制的实现过程中为了让行级锁定和表级锁定共存，InnoDB也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。
				2.意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以在需要锁定行的表上面添加一个合适的意向锁。
					如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。
					如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。
					意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。
				意向锁是InnoDB自动加的，不需用户干预。
		

			注：
				锁是自动加的：
					对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
					对于普通SELECT语句，InnoDB不会加任何锁：
						例：
							1.执行
								BEGIN;
								SELECT * FROM test for UPDATE;
							2.再开启一个控制台执行更新语句，或直接navicat进行更新，会发现未返回结果
							3. 再1界面执行commit后，发现2返回了，可见1加排他锁成功。
							4. 1改造下
							执行
								BEGIN;
								SELECT * FROM test;
							在执行2，发现2返回了，可见对于普通SELECT语句，InnoDB不会加任何锁。
				手动加锁：
					事务可以通过以下语句显示给记录集加共享锁或排他锁：

					共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
						1.用SELECT ... IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。
						2.但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁。
					排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE
				查看引擎：
					show ENGINES;
				 InnoDB行锁模式兼容性列表：
					....
					https://www.cnblogs.com/Arlen/articles/1756616.html
mysql为啥会锁死表？
	https://blog.csdn.net/yangfengjueqi/article/details/81062123
	https://www.cnblogs.com/ShaunChen/p/7492056.html	
		MySQL如果频繁的修改一个表的数据，那么这么表会被锁死。造成假死现象。
		
	释放锁：
		./释放锁.txt
		
		
附	https://blog.csdn.net/weixin_41050155/article/details/88088419
	https://blog.csdn.net/caohao0591/article/details/79887028