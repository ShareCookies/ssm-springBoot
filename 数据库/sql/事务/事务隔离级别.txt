事务并发问题：
	多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。
	当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。

	可能会导致以下的问题：
		脏读（Dirty Read）: 
			A事务读取B事务尚未提交的数据并在此基础上操作，那么A读取到的数据就是脏数据。
				附：
					当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中。
					这时另外一个事务也访问了这个数据，然后使用了这个数据。
					因为这个数据是还没有提交的数据，那么另外一个事务读到的数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
					因为有可能数据对应事务回滚了，或在次被别的事务读取了等等问题。
					https://blog.csdn.net/iteye_6233/article/details/82374373
		不可重复读（UnrepeatableRead）: 
			事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。
			附：
				一个事务内多次读同一数据
				a 读取 -》b 修改（提交）-》a读取
				总结：a 前后读取到的数据不一样
		幻读（Phantom Read）: 
			A事务读取了几行数据，接着B事务插入了一些数据，A事务再查询发现多了一些原本不存在的记录。
			就好像发生了幻觉一样，所以称为幻读。	
			附：
				一个事务内读取的数据量不一致
				a 读取  b 新增（提交） a读取
				总结：a 前后读取到的数据量不一样
			附：
				不可重复读和幻读区别：
					不可重复读的重点是数据修改
						比如多次读取一条记录发现其中某些列的值被修改
					幻读的重点在于新增或者删除，或某行记录被修改
						比如多次读取一条记录发现记录增多或减少了。
					
		丢失修改（Lost To Modify）: 
			指两事务都访问并修改一个数据，其中一个事务修改结果就被丢失，因此称为丢失修改。	
				例：
					第1类丢失更新(回滚丢失，Lost update) ：事务A撤销时，把已经提交的事务B的更新数据覆盖了。
						事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=19，事务2修改A=21，事务2提交事务A=21，接着事务1异常回滚事务A=20。
					第2类丢失更新(覆盖丢失/两次更新问题，Second lost update) ：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。
						事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
			如何避免丢失修改:
				https://blog.csdn.net/qq_39445473/article/details/90488673
				介绍：
					丢失更新处理方式，基本两种思路，一种是悲观锁，另外一种是乐观锁；
					悲观锁：简单的说就是一种假定这样的问题是高概率的，最好一开始就锁住，免得更新老是失败；
					乐观锁：另外一种假定这样的问题是小概率的，最后一步做更新的时候再锁住，免得锁住时间太长影响其他人做有关操作。
					附：
						锁必须在事务内进行声明。在事务外声明的锁将不具备效应。
				通过数据库的锁机制解决丢失更新
					事务中sql均加排它锁。
					如此事务未经提交，其他的事务根本没法获取修改权，因此排它锁可以用来控制丢失更新。
						附：
							mysql事务中不手动加排他锁，sql语句默认是无锁的。
						附：
							需要说明的是有时候，当知道某一行会发生并发修改的时候，可以把锁定的范围缩小。例如使用select * from t_account t wheret.id=‘1’ for update; 这样能够比较好地把控上锁的粒度，这种基于行级上锁的方法叫"行级锁"。

					使用乐观锁.
						乐观锁的原理是：认为事务不一定会产生丢失更新，让事务进行并发修改，不对事务进行锁定。发现并发修改某行数据时，乐观锁抛出异常，让用户解决。
						实现：
						旧值条件（前镜像）法：
							就是在sql更新时使用旧的状态值做条件，SQL大致如下 Update table set col1 =newcol1value, col2 = newcol2value…. where col1 =oldcol1value and col2 = oldcol2value….
							在上面的例子中我们就可以把当前工资作为条件进行更新，如果这条记录已经被其他会话更新过，则本次更新了0行，这里我们应用系统一般会做个提示告知用户重新查询更新。这个取哪些旧值作为条件更新视具体系统实际情况而定。（这种方式有可能发生阻塞，如果应用其他地方使用悲观锁法长时间锁定了这条记录，则本次会话就需要等待，所以使用这种方式时最好统一使用乐观锁法）。

						使用版本列法（推荐优先使用）：
							其实这种方式是一个特殊化的前镜像法，就是不需要使用多个旧值做条件，只需要在表上加一个版本列，这一列可以是NUMBER或DATE/TIMESTAMP列，加这列的作用就是用来记录这条数据的版本（在表设计时一般我们都会给每个表增加一些NUMBER型和DATE型的冗余字段，以便扩展使用，这些冗余字段完全可以作为版本列用），在应用程序中我们每次操作对版本列做维护即可。在更新时我们把上次版本作为条件进行更新。

						使用校验和法（不推荐）

						使用ORA_ROWSCN法（不推荐）
		
		
事务隔离级别：
	https://blog.csdn.net/dengjili/article/details/82468576
	为了避免上面出现的几种情况，标准SQL规范中定义了4个事务隔离级别，不同的隔离级别能避免不同的事务问题。
		事务隔离级别用来解决事务并发导致的问题。
	SQL 标准定义了四个隔离级别：
		READ-UNCOMMITTED(读取未提交)： 		
			最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
		READ-COMMITTED(读取已提交)： 
			允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
		REPEATABLE-READ(可重复读)： （mysql默认）
			对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
			附：
				是禁止别的事务修改，当前事务读取的数据吗。
				答：不是，别的事务任可以修改，只是这个事务中对同一字段的多次读取结果都是一致的，估计是通过日志实现对同一字段的多次读取结果都是一致的。
			附:
				可重复读事务的证明案例：
					会话1：
						BEGIN;
						SELECT * from EGOV_RECEIVAL  WHERE id='XHzYayMaJdQRhxzh';
					会话2：
						UPDATE EGOV_RECEIVAL SET SOURCE_UNIT = '111111' WHERE id='XHzYayMaJdQRhxzh';
					会话3：
						SELECT * from EGOV_RECEIVAL  WHERE id='XHzYayMaJdQRhxzh';
					介绍:
						会话1开启事务，然后查询。
						会话2修改。
						会话1在查询。会话3在查询。
							由于会话1的事务未结束，且是REPEATABLE READ，所以会话1查询的数据是旧数据（看不到会话2的更改）。
							会话3查询是可以看到效果的。
							因此证明了对REPEATABLE READ事务，是可以避免阻止脏读和不可重复读的。
					附：
						navicat中的会话是指，新建一个查询界面，即一个查询界面就是一个会话。
				可重复读事务下，语句未提交，其他事务是读取不到值的：
					插入或修改未提交，别的事务是读取不到值的。
					会话1：插入或修改，未提交。
						begin; INSERT INTO EGOV_RECEIVAL (...);
						或则 BEGIN; UPDATE EGOV_RECEIVAL SET DRAFT_USER = "11"
					会话2：别的事务是读取不到值的。
						begin;SELECT * FROM `EGOV_RECEIVAL` WHERE `SUBJECT` = '66' LIMIT 0,1000		
		SERIALIZABLE(可串行化)： 
			最高的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
	MySQL 隔离级别：
		InnoDB 存储引擎默认支持的隔离级别是 REPEATABLE-READ。
			附：
				可以通过SELECT @@transaction_isolation命令来查看;
				附：
					SELECT @@tx_isolation
					https://blog.csdn.net/qq_41384351/article/details/94345508
		注：
			1.与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，
			因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。
			所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。
			
			2.因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) 。
			但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。
			
			3.InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。
	?
		事务隔离级别和锁的关系，或则说事务隔离级别的实现
