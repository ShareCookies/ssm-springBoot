事务并发问题：
	多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。
	可能会导致以下的问题：
		脏读（Dirty Read）: 
			
			当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中。
			这时另外一个事务也访问了这个数据，然后使用了这个数据。
			因为这个数据是还没有提交的数据，那么另外一个事务读到的数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
			hcg：
				情况：
				对同一数据
				a 修改（未提交） b 读取 
				总结：b读取的数据不准确，为脏读
		丢失修改（Lost To Modify）: 
			指一个事务读取一个数据时，同时另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
			hcg：
				情况：
				对同一数据
				a 修改（未提交） b 修改（未提交）
				总结：a或b修改的数据丢失
			如何避免丢失修改:
				https://blog.csdn.net/qq_39445473/article/details/90488673
				
				?使用存储过程:
					如果更新返回的值为0，说明之前数据已经被更改，报错。
					https://blog.csdn.net/iteye_6233/article/details/82374373
		不可重复读（UnrepeatableRead）: 
			指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
			hcg：
				情况：
				一个事务内多次读同一数据
				a 读取  b 修改（提交） a读取
				总结：a 前后读取到的数据不一样
		幻读（Phantom Read）: 
			幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。	
			hcg：
				情况：
				一个事务内读取的数据量不一致
				a 读取  b 新增（提交） a读取
				总结：a 前后读取到的数据量不一样
		附：
		不可重复读和幻读区别：
			不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。
事务隔离级别：
	https://blog.csdn.net/dengjili/article/details/82468576
	为了避免上面出现的几种情况，标准SQL规范中定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。
	SQL 标准定义了四个隔离级别：
		READ-UNCOMMITTED(读取未提交)： 		
			最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
		READ-COMMITTED(读取已提交)： 
			允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
		REPEATABLE-READ(可重复读)： 
			对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
			hcg：是禁止别的事务修改，当前事务读取的数据吗。
		SERIALIZABLE(可串行化)： 
			最高的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
		例:
			可重复读事务的证明案例：
				会话1：
					BEGIN;
					SELECT * from EGOV_RECEIVAL  WHERE id='XHzYayMaJdQRhxzh';
				会话2：
					UPDATE EGOV_RECEIVAL SET SOURCE_UNIT = '111111' WHERE id='XHzYayMaJdQRhxzh';
					由于会话1的事务未结束，且是REPEATABLE READ，所以会话2的事务并没有提交成功。
					仅会话2中是可以看到修改效果的，会话1和其余会话是看不到修改效果的
						SELECT * from EGOV_RECEIVAL  WHERE id='XHzYayMaJdQRhxzh';
				注：
					查看正在执行的事务：SELECT * FROM information_schema.innodb_trx;
				附：
					navicat中的会话是指，新建一个查询界面，即一个查询界面就是一个会话。
	MySQL 隔离级别：
		InnoDB 存储引擎默认支持的隔离级别是 REPEATABLE-READ。
			附：
				可以通过SELECT @@transaction_isolation命令来查看;
				附：
					SELECT @@tx_isolation
					https://blog.csdn.net/qq_41384351/article/details/94345508
		注：
			1.与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，
			因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。
			所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。
			
			2.因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) 。
			但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。
			
			3.InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。
