一个事务上写的sql，是又执行到数据库的吧，那为啥navicate直接查询是查不到提交的事务的了，难道事务单独开启了一个视图，把它写的写在视图里？
原子性是事务提交后才起作用？那还要undo干嘛？所以不是把，和上面又冲突了？



		3、I (Isolation 隔离性) 
			介绍：
				与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。				
				定义：
					并发执行的事务彼此无法看到对方的中间状态。
						即隔离性是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
				附：
					严格的隔离性，对应了事务隔离级别中的Serializable（可串行化），但实际应用中出于性能方面的考虑很少会使用可串行化，一般为可重复读。
			例：
				事务1：是从A账户转100元至B账户，在这个交易还未完成的情况下。事务2：如果此时B查询自己的账户，是看不到新增加的100元的。(非读未提交隔离级别下)
			hcg:
				并发的事务之间不会互相影响。
				（所以这里就会可能发生丢失修改吗！但你可以提高事务访问级别，来避免这个问题，或事务中sql加排他锁来避免该问题？）

隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作（暂时不考虑带锁读等特殊操作），那么隔离性的探讨，主要可以分为两个方面：
	（一个事务）写操作对（另一个事务）写操作的影响：
		此时mysql是通过锁机制保证隔离性的。
	（一个事务）写操作对（另一个事务）读操作的影响：MVCC 保证隔离性
锁机制
首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。

锁机制的基本原理可以概括为：
	事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；
	该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。

按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。
	但是由于加锁本身需要消耗资源（获得锁、检查锁、释放锁等都需要消耗资源），因此在锁定数据较多情况下使用表锁可以节省大量资源。
	MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。

如何查看锁信息：有多种方法可以查看 InnoDB 中锁的情况，例如

select * from information_schema.innodb_locks; # 查询锁的概况
show engine innodb status; # 查询 InnoDB 整体状态，其中包括锁的情况































详细分析MySQL事务日志(redo log和undo log)
	https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html

？
	MVCC ：
		https://segmentfault.com/a/1190000012650596


Mysql事务的实现原理：
	数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准：
	“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。
	“读已提交”隔离级别下，这个视图是在每个 SQL语句开始执行的时候创建的。
	“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图
	“串行化”隔离级别下直接用加锁的方式来避免并行访问

https://guobinhit.blog.csdn.net/article/details/61200815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.control&dist_request_id=a3a2ba39-036d-4552-abd7-1eac3e380c28&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.control
https://www.cnblogs.com/ffdsj/p/12266539.html
原子性
	那MySQL是如何实现原子性的：
		mysql通过undo log来实现原子性。
		undo log记录了：
			...

		附：
			undo log是实现事务原子性：
				...
				附：
					这样每一次数据的变化（cud）都会伴随一条undo log的生成，并且在日志生成之后会先行持久化到磁盘之上，比数据持久化早一些。
一致性
　　对于一个数据库来说，总是从一种状态转移到另外一种状态：比如我要从一个银行卡转出400块钱到另外一个理财的账户中
start transaction;
select balance from bank where name="wyf";
//生成重做日志balance=600
update bank set balance=balance-400;
//生成重做日志amount=400
update finance set amount=amount+400；
commit；
　　假如执行完 update bank set balance = balance - 400;之后数据库发生了异常了，银行肯定不允许客户钱平白无故的减少，就可以回滚到最初的状态。又或者事务提交之后，缓冲池还没同步到磁盘的时候死机了了，这也是不能接受的，应该在重启的时候恢复并持久化。假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以从这个角度看，隔离性也是对一致性的一种逆向削弱。