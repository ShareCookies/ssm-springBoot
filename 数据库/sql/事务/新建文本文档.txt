原子性（Atomicity）
定义
原子性，是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个 SQL 语句执行失败，则已执行的语句也必须回滚，数据库回退到事务开始前的状态。

实现原理：undo log
	InnoDB 存储引擎提供了两种事务日志：
		redo log（重做日志）和undo log（回滚日志）。
		其中，redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。

	实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 SQL 语句。
	InnoDB 实现回滚，靠的是undo log：
		介绍：
			当事务对数据库进行修改时，InnoDB 会生成对应的undo log；
			如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
			？
				undo log具体记录了什么：
	                ...
	                cud类型、修改前数据、修改后数据
		实现思路：
			undo log属于逻辑日志，它记录的是 SQL 执行的相关信息。当发生回滚时，InnoDB 会根据undo log的内容做与之前相反的工作：
				对于每个insert，回滚时会执行delete；
				对于每个delete，回滚时会执行insert；
				对于每个update，回滚时会执行一个相反的update，把数据改回去。
			例：
				以update操作为例：
				当事务执行update时，其生成的undo log中会包含被修改行的主键（以便知道修改了哪些行）、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。
持久性（Durability）
定义
持久性，是指事务一旦提交，它对数据库的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响。

实现原理：redo log
	下面先聊一下redo log存在的背景：

		InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。
		为此，InnoDB 提供了缓存（Buffer Pool），Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：
		当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；
		当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中，这一过程称为“刷脏”。

	Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。
	于是，redo log被引入来解决这个问题：
		当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；
			？
				当事务提交时，会调用fsync接口对redo log进行刷盘。
		如果 MySQL 宕机，重启时可以读取redo log中的数据，对数据库进行恢复。
		附：
			！
				redo log采用的是 WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。
	附：
		既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘（即刷脏）要快：
			主要有以下两方面的原因：

			刷脏是随机 IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序 IO。
			刷脏是以数据页（Page）为单位的，MySQL 默认页大小是 16 KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效 IO 大大减少。
		binlog（二进制日志）：
			我们知道，在 MySQL 中还存在binlog（二进制日志）也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：
				作用不同：redo log是用于crash recovery的，保证 MySQL 宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。
				层次不同：redo log是 InnoDB 存储引擎实现的，而binlog是 MySQL 的服务器层实现的，同时支持 InnoDB 和其他存储引擎。
				内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于 SQL 语句、基于数据本身或者二者的混合。
				写入时机不同：
					binlog在事务提交时写入；redo log的写入时机相对多元：
					前面曾提到当事务提交时会调用fsync对redo log进行刷盘，这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。
					除了事务提交时，还有其他刷盘时机，如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。

详细分析MySQL事务日志(redo log和undo log)
	https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html
redolog是自动执行的吗：
	innodb的恢复行为：
		在启动innodb的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。

		因为redo log记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如二进制日志)要快很多。而且，innodb自身也做了一定程度的优化，让恢复速度变得更快。

		重启innodb时，checkpoint表示已经完整刷到磁盘上data page上的LSN，因此恢复时仅需要恢复从checkpoint开始的日志部分。
			例如，当数据库在上一次checkpoint的LSN为10000时宕机，且事务是已经提交过的状态。启动数据库时会检查磁盘中数据页的LSN，如果数据页的LSN小于日志中的LSN，则会从检查点开始恢复。

			还有一种情况，在宕机前正处于checkpoint的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度。这时候一宕机，数据页中记录的LSN就会大于日志页中的LSN，在重启的恢复过程中会检查到这一情况，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。

	？
		binlog二进制日志应该不会被自动执行吧

？
	MVCC ：
		https://segmentfault.com/a/1190000012650596


Mysql事务的实现原理：
	数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准：
	“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。
	“读已提交”隔离级别下，这个视图是在每个 SQL语句开始执行的时候创建的。
	“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图
	“串行化”隔离级别下直接用加锁的方式来避免并行访问

https://guobinhit.blog.csdn.net/article/details/61200815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.control&dist_request_id=a3a2ba39-036d-4552-abd7-1eac3e380c28&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.control
https://www.cnblogs.com/ffdsj/p/12266539.html
原子性
	那MySQL是如何实现原子性的：
		mysql通过undo log来实现原子性。
		undo log记录了：
			...

		附：
			undo log是实现事务原子性：
				...
				附：
					这样每一次数据的变化（cud）都会伴随一条undo log的生成，并且在日志生成之后会先行持久化到磁盘之上，比数据持久化早一些。
一致性
　　对于一个数据库来说，总是从一种状态转移到另外一种状态：比如我要从一个银行卡转出400块钱到另外一个理财的账户中
start transaction;
select balance from bank where name="wyf";
//生成重做日志balance=600
update bank set balance=balance-400;
//生成重做日志amount=400
update finance set amount=amount+400；
commit；
　　假如执行完 update bank set balance = balance - 400;之后数据库发生了异常了，银行肯定不允许客户钱平白无故的减少，就可以回滚到最初的状态。又或者事务提交之后，缓冲池还没同步到磁盘的时候死机了了，这也是不能接受的，应该在重启的时候恢复并持久化。假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以从这个角度看，隔离性也是对一致性的一种逆向削弱。