https://www.jianshu.com/p/36a7775b04ec
什么是MQ（Message Queue 消息队列）:
	介绍：
		我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。
			消息队列是典型的生产者、消费者模型。
				生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。
				因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。
		目前使用较多的消息队列有RabbitMQ，Kafka，RocketMQ，ActiveMQ。
	为什么要用消息队列:
		消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。

		我觉得使用消息队列主要有两点好处：
		1.通过异步处理提高系统性能（削峰、减少响应所需时间）;
			https://www.jianshu.com/p/36a7775b04ec
			在不使用消息队列服务器的时候，用户的请求数据通常直接写入数据库。（高并发的情况下数据库压力剧增，使得响应速度变慢，或导致死锁等）
			但是在使用消息队列服务器之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。
			例：
				秒杀活动中用户在提交订单之后，订单数据写入消息队列之后就立即返回给用户了（不返回用户订单提交成功而是等待等消息），需要在消息队列的订单消费者进程真正处理完该订单之后（甚至出库后），再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。

		2.降低系统耦合性。
			消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。
			附：
				1.对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。
				2.
					为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。
					在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。
		附：
			如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。

			使用消息队列带来的一些问题：
				系统可用性降低： 			
					系统可用性在某种程度上降低。
					在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！
				系统复杂性提高： 
					加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
				一致性问题： 	
					我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!
			MQ典型应用场景：
				流量削峰。
					例如秒杀活动，在短时间内访问量急剧增加，使用消息队列，当消息队列满了就拒绝响应，跳转到错误页面，这样就可以使得系统不会因为超负载而崩溃。
				
				应用解耦。
					假设某个服务A需要给许多个服务（B、C、D）发送消息，当某个服务（例如B）不需要发送消息了，服务A需要改代码再次部署；当新加入一个服务（服务E）需要服务A的消息的时候，也需要改代码重新部署；另外服务A也要考虑其他服务挂掉，没有收到消息怎么办？要不要重新发送呢？是不是很麻烦，使用MQ发布订阅模式，服务A只生产消息发送到MQ，B、C、D从MQ中读取消息，需要A的消息就订阅，不需要了就取消订阅，服务A不再操心其他的事情，使用这种方式可以降低服务或者系统之间的耦合。
				异步处理。
					把消息放入消息中间件中，让消费者自己来获取,或等到需要的时候再去处理.
					附：
						线程等也能达到异步的效果，但方式不一样：
							线程等是自己开辟一个线程去调用他人，达到异步效果。
							消息队列是自己发布消息到队列，然后他人在去队列取，来达到异步效果。
						也能达到应用对接的效果，a，b两个不同厂商应用也可以通过消息队列等来达到消息对接的效果。

				日志处理！
AMQP和JMS:
	介绍:
		现在实现MQ的有两种主流方式：AMQP、JMS。
		JMS定义了统一的接口，限定必须使用Java语言 来对消息操作进行统一；
		AMQP只是协议，不规定实现方式，是通过规定协议来统一数据交互的格式,因此是跨语言的。
	JMS API：
		https://blog.csdn.net/aking21alinjuju/article/details/6051421
		介绍：
			JMS JAVA Message Service,java消息服务。
			JMS API是一系列的接口及相关语义的集合，通过这些接口和和其中的方法，JMS客户端如何去访问消息系统，完成创建、发送、接收和读取企业消息系统中消息。
			附：JMS API 作用：
				在JMS之前，每一家MOM厂商都用专有API为应用程序提供对其产品的访问，通常可用于许多种语言，其中包括Java语言。
	            JMS通过MOM为Java程序提供了一个发送和接收消息的标准的、便利的方法。用JMS编写的程序可以在任何实现JMS标准的MOM上运行。
	            JMS可移植性的关键在于：JMS API是由Sun作为一组接口而提供的。提供了JMS功能的产品是通过提供一个实现这些接口的提供者来做到这一点的。开发人员可以通过定义一组消息和一组交换这些消息的应用程序，建立JMS应用程序，实现异步通讯。
			附：
				ActiveMQ 就是基于 JMS 规范实现的。

	JMS提供了两种消息通信模型：
		1.点到点（P2P）模型
			使用队列（Queue）作为消息通信载体；
			一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。
				比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）
		2.发布/订阅（Pub/Sub）模型
			使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。
	AMQP协议：
		介绍：
			Advanced Message Queuing Protocol 高级消息队列协议
			一个提供统一消息服务的应用层标准协议 ,为面向消息的中间件设计，兼容 JMS。
			附：
				AMQP只是协议，不规定实现方式，是通过规定协议来统一数据交互的格式,因此是跨语言的。
				？因此不管任何语言环境只要符合数据格式和规范就行吗
			附：
				RabbitMQ是基于AMQP协议实现的。
		AMQP协议中间的几个重要概念：
			Server：
				接收客户端的连接，实现AMQP实体服务。
			Connection：
				连接，应用程序与Server的网络连接，TCP连接。
			Channel：
				信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。
			Message：
				消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。
				消息由Properties和Body组成。
					Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；
					Body就是消息体内容。
			Virtual Host：
				虚拟主机，用于逻辑隔离。
				一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。
			Exchange：
				交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。
				如果路由不到，或者返回给生产者，或者直接丢弃。
				RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。
			Binding：
				绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。
			RoutingKey：
				路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”。
			Queue：
				消息队列，用来保存消息，供消费者消费。
		AMQP支持的消息通信模型：
			由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，
			而 JMS 仅支持 队列 和 主题/订阅 方式两种。

	附：
		区别：
			1. 兼容性：
				AMQP天然具有跨平台、跨语言特性：
					AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。
				JMS无跨语言特性(具有跨平台)：
					在 Java 体系中，多个java client均可以通过JMS进行交互，不需要应用修改代码。

			2. 支持的消息通信模型：
                AMQP:
                    由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，
                JMS:
                   而 JMS 仅支持 队列 和 主题/订阅 方式两种。
            3. 支持的消息类型
                JMS 支持TextMessage、MapMessage 等复杂的消息类型；
                而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。
		!
			java实现amqp应用层协议
附：
	常用消息队列产品介绍和对比
		https://www.cnblogs.com/xifengxiaoma/p/9391647.html
		现在比较常见的消息队列产品主要有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、RocketMQ等。
		RabbitMQ
			RabbitMQ用erlang语言开发，是AMQP（高级消息队列协议）的标准实现，支持多种客户端。
			用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。
		Kafka
			Kafka是一种高吞吐量的分布式发布订阅消息系统。
			Kafka可以处理消费者规模的网站中的所有动作流数据。
			例：
				（网页浏览，搜索和其他用户的行动）等动作，这些数据通常由于吞吐量的要求而通过处理日志和日志聚合来解决。
				...
					Hadoop...
					Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群机来提供实时的消费。
		RocketMQ
			RocketMQ是阿里开源的消息中间件，纯Java开发，
			具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。
				RocketMQ思路起源于Kafka，但并不是简单的复制，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景，支撑了阿里多次双十一活动。

				因为是阿里内部从实践到产品的产物，因此里面很多接口、api并不是很普遍适用。可靠性毋庸置疑，而且与Kafka一脉相承（甚至更优），性能强劲，支持海量堆积。
		横向对比
			特性	ActiveMQ	RabbitMQ	Kafka	RocketMQ
			PRODUCER-COMSUMER	支持	支持	支持	支持
			PUBLISH-SUBSCRIBE	支持	支持	支持	支持
			REQUEST-REPLY	支持	支持	-	支持
			API完备性	高	高	高	低（静态配置）
			多语言支持	支持，JAVA优先	语言无关	支持，JAVA优先	支持
			单机呑吐量	万级	万级	十万级	单机万级
			消息延迟	-	微秒级	毫秒级	-
			可用性	高（主从）	高（主从）	非常高（分布式）	高
			消息丢失	-	低	理论上不会丢失	-
			消息重复	-	可控制	理论上会有重复	-
			文档的完备性	高	高	高	中
			提供快速入门	有	有	有	无
			首次部署难度	-	低	中	高
			注： - 表示尚未查找到准确数据
		总结
			RabbitMQ大而稳，Kakfa和RocketMQ快而强劲。
			RocketMQ虽然目前还很多不完善，但是一旦在Apache孵化成为顶级项目，前途也是不可限量的。
		附：
			Redis
				Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。
				虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。
				对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。
	SpringCloud Stream
		可以使用SpringCloud Stream来与具体的消息队列产品解耦。

RabbitMQ:
	./RabbitMQ.txt