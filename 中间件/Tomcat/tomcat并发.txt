Tomcat能支持的并发：
	https://www.cnblogs.com/zhaosq/p/10870762.html
	介绍：
		对 tomcat 来说，每一个进来的请求都需要一个线程，直到该请求结束。
		如果同时进来的请求多于当前可用的请求处理线程数，额外的线程就会被创建，直到到达配置的最大线程数(maxThreads属性值)。
		如果仍就同时接收到更多请求，这些来不及处理的请求就会在Connector创建的ServerSocket中堆积起来，
			附：
				直到到达最大的配置值(acceptCount属性值)。至此，任何再来的请求将会收到connection refused错误，直到有可用的资源来处理它们。
	tomcat配置：
		http://www.cnblogs.com/shenpengyan/articles/5938749.html
	附：
	一个Tomcat最多支持多少用户的并发：
		1. tomcat 默认配置的最大请求数是 150，即同时支持 150 个并发。
		2. 并发数能调到多大，
		建议200，当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。
		具体能承载多少并发，需要看硬件的配置(CPU、内存)
		附：
		操作系统对于进程中的线程数有一定的限制：
			Windows 每个进程中的线程数不允许超过 2000
			Linux 每个进程中的线程数不允许超过 1000
			另外，在 Java 中每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用。
	Tomcat 通信方式：
		https://blog.csdn.net/dxyzhbb/article/details/101444786?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ELandingCtr%7ERate-2.queryctrv4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ELandingCtr%7ERate-2.queryctrv4&utm_relevant_index=5
		Tomcat支持三种接收请求的处理方式：BIO、NIO、APR 。 
		BIO：
			Tomcat 默认的 HTTP 实现是采用阻塞式的 Socket 通信，每个请求都需要创建一个线程处理。
			这种模式下的并发量受到线程数的限制。
		NIO ：
			Tomcat 还可以配置 NIO 方式的 Socket 通信，在性能上高于阻塞式的，每个请求也不需要创建一个线程进行处理，并发能力比前者高。
			？但没有阻塞式的成熟。
			应用：
				...
		APR：
			简单理解，就是从操作系统级别解决异步IO问题，大幅度的提高服务器的处理和响应性能， 也是Tomcat运行高并发应用的首选模式。
			启用这种模式稍微麻烦一些，需要安装一些依赖库。
			应用：
				...
			
tomcat原理：
	核心思路：
		Tomcat服务器接受客户请求并做出响应的过程如下：
			1）客户端（通常都是浏览器）访问Web服务器，发送HTTP请求。 
			2）Web服务器接收到请求后，传递给Servlet容器。 
				这里是因为Servlet容器通过指定方式监听linux服务器指定端口，linux才会把请求转给Servlet容器吧。
			？
				Servlet容器是怎么接收请求的了
			3）Servlet容器调用某个Servlet实例，向其传递表示请求和响应的对象
				注：
					Servlet容器加载完Servlet后，会产生Servlet实例。 
			4）Servlet实例使用请求对象得到客户端的请求信息，然后进行相应的处理。 
			5）Servlet实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web服务器。
		附：

			Servlet实例：
				一个类实现了Servlet接口，然后Web容器启用后加载Servlet并将其实例化，其就叫Servlet实例。
			Servlet是如何处理浏览器请求的：
				https://blog.csdn.net/weixin_33369252/article/details/113317227
				浏览器发起请求到服务器，会遵循HTTP协议将请求数据发送给服务器。
				那么服务器(servlet容器)每接受一个请求后，
				就创建一个对象专门的存储此次请求的请求数据(request),
				同时也创建一个专门对象(response)存储此次请求的响应数据。
				最后调用servlet的方法，并把这两个参数传递过去。

					Request 对象
						服务器接收到浏览器的请求后，会创建一个 Request 对象，对象中存储了此次请求相关的请求数据。
						服务器在调用 Servlet 时会将创建的Request 对象作为实参传递给 Servlet 的方法。

					Response 对象：
						问题：
							在使用 Request 对象获取了请求数据并进行处理后，处理的结果如何显示到浏览器中呢？
						解释：
							服务器在调用指定的 Servlet 进行请求处理的时候，会给 Servlet 的方法传递两个实参 request 和 response。
							其中 request 中封存了请求相关的请求数据，而 response 则是用来进行响应的一个对象。
			Servlet如何处理多个请求访问：(Servlet容器如何处理多个请求访问)
				https://blog.csdn.net/superviser3000/article/details/88024516
				Servlet容器默认是采用单实例多线程的方式处理多个请求的。
				其过程如下：
				　　1.当web服务器启动的时候（或客户端发送请求到服务器时），Servlet就被加载并实例化(只存在一个Servlet实例)；
					　　附：
							容器初始化Servlet主要就是读取配置文件。
							例如tomcat,可以通过servlet.xml的<Connector>设置线程池中线程数目，初始化线程池通过web.xml,初始化每个参数值等等。
				　　3.当请求到达时，Servlet容器通过调度线程(Dispatchaer Thread) 调度它管理下线程池中等待执行的线程（Worker Thread）分给请求者；
				　　4.线程执行Servlet的service方法；
					？？？
						线程与servlet怎么结合的了，没看懂?
						servlet全程只有一个？
				　　5.请求结束，放回线程池，等待被调用；
				注：
					因此要避免使用实例变量（成员变量），因为如果存在成员变量，可能发生多线程同时访问该资源时，都来操作它，照成数据的不一致，因此产生线程安全问题。	
			Tomcat就是一个Servlet容器。
				附：Tomcat是如何处理jsp的
					/JavaEE\servlet\
	源码：